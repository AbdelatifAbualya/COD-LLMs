<!DOCTYPE html><html lang="en" class="dark"><head><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Reasoning Studio - CoT vs CoD</title>
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&amp;family=JetBrains+Mono:wght@400;500&amp;display=swap" rel="stylesheet">
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Marked.js for Markdown parsing -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <!-- Highlight.js for code highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
  <!-- jsPDF for PDF generation -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            primary: {
              50: '#eef2ff',
              100: '#e0e7ff',
              200: '#c7d2fe',
              300: '#a5b4fc',
              400: '#818cf8',
              500: '#5686f5', // Primary accent color
              600: '#4f46e5',
              700: '#4338ca',
              800: '#3730a3',
              900: '#312e81',
              950: '#1e1b4b',
            },
            dark: {
              100: '#d1d5db',
              200: '#9ca3af',
              300: '#6b7280',
              400: '#4b5563',
              500: '#374151',
              600: '#1f2937',
              700: '#111827',
              800: '#0d1117',
              900: '#030712',
            }
          },
          fontFamily: {
            sans: ['Inter', 'ui-sans-serif', 'system-ui', 'sans-serif'],
            mono: ['JetBrains Mono', 'ui-monospace', 'monospace'],
          },
        }
      }
    };
  </script>

  <style>
    /* Base Styles */
    :root {
      --primary: #5686f5;
      --primary-hover: #4169e1;
      --success: #10b981;
      --warning: #f59e0b;
      --error: #ef4444;
    }
    
    /* Custom Scrollbar */
    ::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }
    
    ::-webkit-scrollbar-track {
      background: rgb(20, 24, 33);
      border-radius: 8px;
    }
    
    ::-webkit-scrollbar-thumb {
      background: rgba(86, 134, 245, 0.6);
      border-radius: 8px;
    }
    
    ::-webkit-scrollbar-thumb:hover {
      background: rgba(86, 134, 245, 0.8);
    }

    /* Thinking Steps Animation */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .thinking-steps {
      animation: fadeIn 0.3s ease;
    }
    
    /* Reflection Step Animation */
    @keyframes reflectionPulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    
    .reflection-step .step-number {
      animation: reflectionPulse 2s infinite;
    }
    
    /* Streaming Indicator Animation */
    @keyframes typingAnimation {
      0% { border-right-color: rgba(86, 134, 245, 0.7); }
      100% { border-right-color: transparent; }
    }
    
    .streaming {
      border-right: 3px solid rgba(86, 134, 245, 0.7);
      animation: typingAnimation 0.8s infinite ease;
    }
    
    @keyframes ellipsisAnimation {
      0% { content: "."; }
      33% { content: ".."; }
      66% { content: "..."; }
      100% { content: "."; }
    }
    
    .streaming-indicator::after {
      content: "...";
      animation: ellipsisAnimation 1.5s infinite;
    }

    /* Tooltip Styling */
    .tooltip {
      position: relative;
      display: inline-block;
    }
    
    .tooltip .tooltip-text {
      visibility: hidden;
      width: 200px;
      background-color: rgb(30, 41, 59);
      color: #fff;
      text-align: center;
      border-radius: 6px;
      padding: 8px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      margin-left: -100px;
      opacity: 0;
      transition: opacity 0.3s;
      font-size: 0.75rem;
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
    }
    
    .tooltip:hover .tooltip-text {
      visibility: visible;
      opacity: 1;
    }

    /* Range Slider Styling */
    input[type="range"] {
      -webkit-appearance: none;
      width: 100%;
      height: 4px;
      background: #1f2937;
      border-radius: 4px;
      outline: none;
      background: linear-gradient(to right, var(--primary) var(--value-percent, 50%), #1f2937 var(--value-percent, 50%)) !important;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: white !important;
      border-radius: 50%;
      cursor: pointer;
      border: 1px solid rgba(0, 0, 0, 0.1) !important;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
      margin-top: -6px;
    }
  </style>
</head>
<body class="bg-dark-800 text-gray-100 font-sans min-h-screen overflow-hidden">
  <div class="flex h-screen">
    <!-- Sidebar -->
    <div class="w-72 bg-dark-700 border-r border-dark-600 flex flex-col p-4 overflow-y-auto hidden md:flex">
      <h2 class="text-xl font-semibold mb-4">Threads</h2>
      <ul id="threadList" class="flex-1 space-y-1 mb-4">
        <li class="bg-dark-600 text-primary-300 px-3 py-2 rounded-md cursor-pointer hover:bg-dark-500 transition">Thread 1</li>
      </ul>
      <div class="space-y-2">
        <button id="newThreadBtn" class="w-full bg-primary-500 hover:bg-primary-600 text-white py-2 px-4 rounded-md transition flex items-center justify-center gap-2">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
          </svg>
          New Thread
        </button>
        <button id="deleteThreadBtn" class="w-full bg-dark-600 hover:bg-dark-500 text-gray-300 py-2 px-4 rounded-md transition">Delete Thread</button>
        <button id="downloadTxtBtn" class="w-full bg-dark-600 hover:bg-dark-500 text-gray-300 py-2 px-4 rounded-md transition">Download TXT</button>
        <button id="downloadPdfBtn" class="w-full bg-dark-600 hover:bg-dark-500 text-gray-300 py-2 px-4 rounded-md transition">Download PDF</button>
        <button id="clearThreadBtn" class="w-full bg-red-600/20 hover:bg-red-600/30 text-red-400 py-2 px-4 rounded-md transition">Clear Thread</button>
        <button id="openFeedbackBtn" class="w-full bg-dark-600 hover:bg-dark-500 text-gray-300 py-2 px-4 rounded-md transition flex items-center justify-center gap-2">
          <span>üí¨</span>
          Feedback
        </button>
      </div>
    </div>

    <!-- Mobile Sidebar Toggle -->
    <div id="mobileSidebarToggle" class="fixed left-4 top-4 bg-dark-700 p-2 rounded-md shadow-lg z-20 md:hidden">
      <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
      </svg>
    </div>

    <!-- Mobile Sidebar -->
    <div id="mobileSidebar" class="fixed inset-0 bg-dark-800 z-30 transform -translate-x-full transition-transform duration-300 md:hidden">
      <div class="w-full h-full flex flex-col">
        <div class="flex justify-between items-center p-4 border-b border-dark-600">
          <h2 class="text-xl font-semibold">Threads</h2>
          <button id="closeMobileSidebar" class="p-2">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
            </svg>
          </button>
        </div>
        <div class="flex-1 p-4 overflow-y-auto">
          <ul id="mobileThreadList" class="space-y-2 mb-4">
            <li class="bg-dark-600 text-primary-300 px-3 py-2 rounded-md cursor-pointer hover:bg-dark-500 transition">Thread 1</li>
          </ul>
          <div class="space-y-2">
            <button id="mobileNewThreadBtn" class="w-full bg-primary-500 hover:bg-primary-600 text-white py-2 px-4 rounded-md transition flex items-center justify-center gap-2">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
              </svg>
              New Thread
            </button>
            <button id="mobileDeleteThreadBtn" class="w-full bg-dark-600 hover:bg-dark-500 text-gray-300 py-2 px-4 rounded-md transition">Delete Thread</button>
            <button id="mobileDownloadTxtBtn" class="w-full bg-dark-600 hover:bg-dark-500 text-gray-300 py-2 px-4 rounded-md transition">Download TXT</button>
            <button id="mobileDownloadPdfBtn" class="w-full bg-dark-600 hover:bg-dark-500 text-gray-300 py-2 px-4 rounded-md transition">Download PDF</button>
            <button id="mobileClearThreadBtn" class="w-full bg-red-600/20 hover:bg-red-600/30 text-red-400 py-2 px-4 rounded-md transition">Clear Thread</button>
            <button id="mobileOpenFeedbackBtn" class="w-full bg-dark-600 hover:bg-dark-500 text-gray-300 py-2 px-4 rounded-md transition flex items-center justify-center gap-2">
              <span>üí¨</span>
              Feedback
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Main Content Area -->
    <div class="flex-1 flex flex-col overflow-hidden">
      <!-- Header -->
      <header class="bg-dark-700 border-b border-dark-600 h-16 flex items-center justify-between px-4 md:px-6">
        <h1 id="pageTitle" class="text-xl font-semibold">Reasoning Studio</h1>
        <div class="flex items-center gap-3">
          <div id="currentModelDisplay" class="bg-dark-600 text-sm px-3 py-1.5 rounded-lg flex items-center">
            <span>llama-3.3-70b</span>
            <span class="bg-green-900/60 text-green-400 text-xs ml-2 px-2 py-0.5 rounded-full">Adaptive</span>
          </div>
          <button id="openSettings" class="flex items-center gap-1.5 bg-dark-600 hover:bg-dark-500 text-gray-300 px-3 py-1.5 rounded-lg transition">
            <span>Settings</span>
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path>
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
            </svg>
          </button>
        </div>
      </header>

      <!-- Chat Messages Area -->
      <div id="chatMessages" class="flex-1 overflow-y-auto p-4 space-y-6"></div>

      <!-- Input Area -->
      <div class="p-4 border-t border-dark-600 bg-dark-700">
        <div class="flex items-start gap-3 rounded-xl bg-dark-600 p-3 shadow-lg border border-dark-500 focus-within:border-primary-500 transition">
          <div class="flex-1">
            <textarea id="userInput" rows="1" class="w-full bg-dark-700 text-gray-100 rounded-lg p-3 focus:outline-none focus:ring-2 focus:ring-primary-500 resize-none text-base" placeholder="Type your message..."></textarea>
          </div>
          <div class="flex flex-col gap-2 mt-1">
            <button id="sendBtn" class="bg-primary-500 hover:bg-primary-600 text-white p-3 rounded-lg transition">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                <path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z"></path>
              </svg>
            </button>
            <label for="fileInput" class="bg-dark-500 hover:bg-dark-400 text-gray-300 p-2 rounded-lg cursor-pointer transition">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13"></path>
              </svg>
            </label>
            <button id="webSearchBtn" class="bg-dark-500 hover:bg-dark-400 text-gray-300 p-2 rounded-lg transition">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
              </svg>
            </button>
          </div>
        </div>
        <input type="file" id="fileInput" class="hidden" multiple="">
        <div id="attachedFiles" class="mt-3 flex flex-wrap gap-3 hidden"></div>
      </div>
    </div>
  </div>

  <!-- Status Notification -->
  <div id="statusNotification" class="fixed bottom-4 right-4 bg-dark-600 text-white py-2 px-4 rounded-lg shadow-lg opacity-0 transition-opacity duration-300 z-50"></div>

  <!-- Settings Modal -->
  <div id="settingsModal" class="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50 hidden">
    <div class="bg-dark-700 rounded-xl shadow-2xl max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto">
      <div class="p-5 border-b border-dark-600 flex justify-between items-center">
        <h2 class="text-xl font-semibold">Settings</h2>
        <button id="closeModalX" class="text-gray-400 hover:text-white">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
          </svg>
        </button>
      </div>
      
      <div class="p-5">
        <!-- Tab Navigation -->
        <div class="bg-dark-600 rounded-lg p-1 flex mb-5">
          <button class="tab-btn flex-1 py-2 px-4 rounded-md text-gray-400 transition" data-tab="modelTab">Model</button>
          <button class="tab-btn flex-1 py-2 px-4 rounded-md text-gray-400 transition" data-tab="reasoningTab">Reasoning</button>
          <button class="tab-btn flex-1 py-2 px-4 rounded-md text-white bg-primary-500" data-tab="parametersTab">Parameters</button>
        </div>
        
        <!-- Model Tab Content -->
        <div id="modelTab" class="tab-content hidden">
          <h3 class="text-lg font-medium mb-4 pb-2 border-b border-dark-600">Model Selection</h3>
          
          <label class="block text-sm font-medium text-gray-300 mb-2">Select Language Model</label>
          <div class="relative mb-5">
            <select id="modelSelect" class="w-full bg-dark-600 border border-dark-500 text-white rounded-lg p-3 focus:outline-none focus:ring-2 focus:ring-primary-500 appearance-none">
              <option value="" disabled="">Choose a model...</option>
              <option value="accounts/fireworks/models/llama-v3p3-70b" selected="">Llama-3 70B</option>
              <option value="accounts/fireworks/models/deepseek-v3">DeepSeek V3</option>
              <option value="accounts/fireworks/models/deepseek-r1">DeepSeek R1 (Reasoner)</option>
              <option value="accounts/fireworks/models/llama4-maverick-instruct-basic">Llama4 Maverick</option>
              <option value="accounts/fireworks/models/llama4-scout-instruct-basic">Llama4 Scout</option>
            </select>
            <div class="absolute inset-y-0 right-0 flex items-center pr-3 pointer-events-none">
              <svg class="w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
              </svg>
            </div>
          </div>
          
          <div id="modelInfoCard" class="bg-dark-600 rounded-lg p-4 border border-dark-500 mb-5 hidden">
            <div class="font-medium text-lg mb-3" id="selectedModelName">Llama-3 70B</div>
            <div class="flex flex-wrap gap-2 mb-3" id="modelTags">
              <span class="bg-primary-500/20 text-primary-300 text-xs px-2 py-1 rounded-full">Latest</span>
              <span class="bg-primary-500/20 text-primary-300 text-xs px-2 py-1 rounded-full">Versatile</span>
              <span class="bg-primary-500/20 text-primary-300 text-xs px-2 py-1 rounded-full">Chat</span>
            </div>
            <p class="text-gray-400 text-sm" id="modelDescription">
              Meta's latest model with strong performance across a wide range of tasks.
            </p>
          </div>
          
          <button id="setModelBtn" class="w-full bg-primary-500 hover:bg-primary-600 text-white py-3 px-4 rounded-lg transition mt-4">
            Set Model
          </button>
        </div>
        
        <!-- Reasoning Tab Content -->
        <div id="reasoningTab" class="tab-content hidden">
          <h3 class="text-lg font-medium mb-4 pb-2 border-b border-dark-600">Reasoning Method</h3>
          
          <div class="bg-dark-600 border border-dark-500 rounded-lg p-4 mb-5">
            <div class="space-y-3">
              <div class="flex items-start">
                <input type="radio" id="standardReasoning" name="reasoningMethod" value="standard" class="w-4 h-4 mt-1 text-primary-500 bg-dark-500 border-dark-400 focus:ring-primary-500 focus:ring-offset-dark-700">
                <label for="standardReasoning" class="ml-3 block text-sm font-medium text-white">
                  Standard (No special prompt)
                  <div class="text-gray-400 text-xs mt-1">Default model behavior with no special reasoning instructions.</div>
                </label>
              </div>
              
              <div class="flex items-start">
                <input type="radio" id="cotReasoning" name="reasoningMethod" value="cot" class="w-4 h-4 mt-1 text-primary-500 bg-dark-500 border-dark-400 focus:ring-primary-500 focus:ring-offset-dark-700">
                <label for="cotReasoning" class="ml-3 block text-sm font-medium text-white">
                  Chain of Thought (CoT)
                  <div class="text-gray-400 text-xs mt-1">Instructs the model to think step-by-step to solve problems. Improves reasoning but uses more tokens.</div>
                </label>
              </div>
              
              <div class="flex items-start">
                <input type="radio" id="codReasoning" name="reasoningMethod" value="cod" checked="" class="w-4 h-4 mt-1 text-primary-500 bg-dark-500 border-dark-400 focus:ring-primary-500 focus:ring-offset-dark-700">
                <label for="codReasoning" class="ml-3 block text-sm font-medium text-white">
                  Chain of Draft (CoD)
                  <div class="text-gray-400 text-xs mt-1">Uses minimal words per step to reduce token usage while maintaining reasoning quality.</div>
                </label>
              </div>
            </div>
          </div>
          
          <!-- COD Word Limit options -->
          <div id="codOptions" class="mb-5">
            <h4 class="text-sm font-medium text-gray-300 mb-2">Word limit per step:</h4>
            <!-- Add wrapper for JS selection -->
            <div class="cod-word-limit-options space-y-2">
              <div class="cod-word-limit-option bg-dark-600 border border-primary-500 rounded-lg p-3 cursor-pointer" data-value="5">
                <div class="flex justify-between items-center">
                  <span class="font-medium">5 words</span>
                  <span class="bg-primary-500/20 text-primary-300 text-xs px-2 py-1 rounded-full">Paper Standard</span>
                </div>
                <p class="text-xs text-gray-400 mt-1">Original paper recommendation</p>
              </div>
              
              <div class="cod-word-limit-option bg-dark-600 border border-dark-500 hover:border-primary-400 rounded-lg p-3 cursor-pointer" data-value="10">
                <div class="flex justify-between items-center">
                  <span class="font-medium">10 words</span>
                </div>
                <p class="text-xs text-gray-400 mt-1">Balanced brevity and clarity</p>
              </div>
              
              <div class="cod-word-limit-option bg-dark-600 border border-dark-500 hover:border-primary-400 rounded-lg p-3 cursor-pointer" data-value="15">
                <div class="flex justify-between items-center">
                  <span class="font-medium">15 words</span>
                </div>
                <p class="text-xs text-gray-400 mt-1">More descriptive steps</p>
              </div>
              
              <div class="cod-word-limit-option bg-dark-600 border border-dark-500 hover:border-primary-400 rounded-lg p-3 cursor-pointer" data-value="17">
                <div class="flex justify-between items-center">
                  <span class="font-medium">17 words</span>
                </div>
                <p class="text-xs text-gray-400 mt-1">Better for complex reasoning</p>
              </div>
              
              <div class="cod-word-limit-option bg-dark-600 border border-dark-500 hover:border-primary-400 rounded-lg p-3 cursor-pointer" data-value="20">
                <div class="flex justify-between items-center">
                  <span class="font-medium">20 words</span>
                </div>
                <p class="text-xs text-gray-400 mt-1">Detailed steps for math &amp; logic</p>
              </div>
            </div>
            
            <div class="mt-5 bg-dark-600 border border-dark-500 rounded-lg p-4">
              <h5 class="font-medium text-sm mb-2 pb-2 border-b border-dark-500">Chain of Draft Example</h5>
              <div class="mt-3 space-y-2">
                <div class="text-gray-400 text-sm">Q: If a fabric store received 45 yards of cotton and used 2/9 of it, how many yards remain?</div>
                <div class="text-primary-300 font-mono text-sm">A: Total: 45 yards. Used: 2/9 √ó 45 = 10 yards. Remaining: 45 - 10 = 35 yards. #### 35 yards</div>
              </div>
            </div>
          </div>
          
          <!-- Self-Reflection Options -->
          <div class="flex justify-between items-center mb-4 pb-2 border-b border-dark-600">
            <h3 class="text-lg font-medium">Self-Reflection for Chain of Draft</h3>
            <label class="relative inline-flex items-center cursor-pointer">
              <input type="checkbox" id="selfReflectionToggle" class="sr-only peer" checked="">
              <div class="w-11 h-6 bg-dark-500 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-primary-800 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-primary-600"></div>
            </label>
          </div>
          
          <div id="selfReflectionInfo" class="bg-dark-600 border border-dark-500 rounded-lg p-4 mb-5">
            <p class="text-gray-400 text-sm mb-3">
              Adds a reflection step after reasoning to help the model verify its own work and catch mistakes.
            </p>
            
            <div class="bg-dark-700 rounded-lg p-4">
              <div class="flex items-center text-purple-300 text-sm font-medium mb-2">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                </svg>
                How Self-Reflection Works
              </div>
              <div class="text-gray-400 text-xs">
                When using Chain of Draft with self-reflection:
                <ul class="list-disc list-inside mt-2 space-y-1">
                  <li>The model reasons step-by-step as usual</li>
                  <li>Before concluding, it adds a reflection step to check for errors</li>
                  <li>This helps identify calculation mistakes, misunderstandings, or logic errors</li>
                  <li>The reflection is highlighted in the UI for easy identification</li>
                </ul>
                <p class="mt-2">This approach improves accuracy with a single API call.</p>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Parameters Tab Content -->
        <div id="parametersTab" class="tab-content">
          <h3 class="text-lg font-medium mb-4 pb-2 border-b border-dark-600">Generation Parameters</h3>
          
          <!-- Streaming Toggle -->
          <div class="flex items-center justify-between mb-5 bg-dark-600 rounded-lg p-3 border border-dark-500">
            <label for="streamingToggle" class="flex items-center cursor-pointer">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-3 text-primary-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
              </svg>
              <div>
                <div class="font-medium text-sm">Enable Streaming Responses</div>
                <div class="text-gray-400 text-xs mt-0.5">See responses appear in real-time as they're generated</div>
              </div>
            </label>
            <label class="relative inline-flex items-center cursor-pointer">
              <input type="checkbox" id="streamingToggle" class="sr-only peer" checked="">
              <div class="w-11 h-6 bg-dark-500 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-primary-800 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-primary-600"></div>
            </label>
          </div>
          
          <!-- Web Search Toggle -->
          <div class="flex items-center justify-between mb-5 bg-dark-600 rounded-lg p-3 border border-dark-500">
            <label for="webSearchToggle" class="flex items-center cursor-pointer">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-3 text-primary-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
              </svg>
              <div>
                <div class="font-medium text-sm">Enable Web Search</div>
                <div class="text-gray-400 text-xs mt-0.5">Allow model to search the web for up-to-date information</div>
              </div>
            </label>
            <label class="relative inline-flex items-center cursor-pointer">
              <input type="checkbox" id="webSearchToggle" class="sr-only peer">
              <div class="w-11 h-6 bg-dark-500 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-primary-800 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-primary-600"></div>
            </label>
          </div>
          
          <!-- Temperature -->
          <div class="mb-4">
            <div class="flex justify-between items-center mb-2">
              <label for="temp" class="block text-sm font-medium text-gray-300">Temperature</label>
              <span id="tempValue" class="text-sm text-gray-400">0.6</span>
            </div>
            <input type="range" id="temp" min="0" max="1" step="0.01" value="0.6" class="w-full h-2 rounded-lg appearance-none cursor-pointer">
            <p class="text-xs text-gray-500 mt-1">Controls randomness: lower values make responses more focused.</p>
          </div>
          
          <!-- Top P -->
          <div class="mb-4">
            <div class="flex justify-between items-center mb-2">
              <label for="topP" class="block text-sm font-medium text-gray-300">Top P</label>
              <span id="topPValue" class="text-sm text-gray-400">1</span>
            </div>
            <input type="range" id="topP" min="0" max="1" step="0.01" value="1" class="w-full h-2 rounded-lg appearance-none cursor-pointer">
            <p class="text-xs text-gray-500 mt-1">Controls diversity via nucleus sampling.</p>
          </div>
          
          <!-- Top K -->
          <div class="mb-4">
            <div class="flex justify-between items-center mb-2">
              <label for="topK" class="block text-sm font-medium text-gray-300">Top K</label>
              <span id="topKValue" class="text-sm text-gray-400">40</span>
            </div>
            <input type="range" id="topK" min="0" max="100" step="1" value="40" class="w-full h-2 rounded-lg appearance-none cursor-pointer">
            <p class="text-xs text-gray-500 mt-1">Limits token selection to top K options.</p>
          </div>
          
          <!-- Presence Penalty -->
          <div class="mb-4">
            <div class="flex justify-between items-center mb-2">
              <label for="presencePenalty" class="block text-sm font-medium text-gray-300">Presence Penalty</label>
              <span id="presencePenaltyValue" class="text-sm text-gray-400">0</span>
            </div>
            <input type="range" id="presencePenalty" min="0" max="2" step="0.01" value="0" class="w-full h-2 rounded-lg appearance-none cursor-pointer">
            <p class="text-xs text-gray-500 mt-1">Reduces repetition of similar tokens.</p>
          </div>
          
          <!-- Frequency Penalty -->
          <div class="mb-4">
            <div class="flex justify-between items-center mb-2">
              <label for="frequencyPenalty" class="block text-sm font-medium text-gray-300">Frequency Penalty</label>
              <span id="frequencyPenaltyValue" class="text-sm text-gray-400">0</span>
            </div>
            <input type="range" id="frequencyPenalty" min="0" max="2" step="0.01" value="0" class="w-full h-2 rounded-lg appearance-none cursor-pointer">
            <p class="text-xs text-gray-500 mt-1">Reduces repetition based on frequency.</p>
          </div>
          
          <!-- Max Tokens -->
          <div class="mb-4">
            <div class="flex justify-between items-center mb-2">
              <label for="maxTokens" class="block text-sm font-medium text-gray-300">Max Tokens</label>
              <span id="maxTokensValue" class="text-sm text-gray-400">4008</span>
            </div>
            <input type="range" id="maxTokens" min="1" max="8192" step="128" value="4008" class="w-full h-2 rounded-lg appearance-none cursor-pointer">
            <p class="text-xs text-gray-500 mt-1">Maximum length of the response (1-8192 tokens for most models).</p>
          </div>
        </div>
        
        <div class="flex justify-end gap-3 pt-4 mt-4 border-t border-dark-600">
          <button id="closeSettings" class="px-4 py-2 bg-dark-600 hover:bg-dark-500 text-gray-300 rounded-lg transition">
            Cancel
          </button>
          <button id="saveSettings" class="px-4 py-2 bg-primary-500 hover:bg-primary-600 text-white rounded-lg transition">
            Save Settings
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Feedback Modal -->
  <div id="feedbackModal" class="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50 hidden">
    <div class="bg-dark-700 rounded-xl shadow-2xl max-w-lg w-full mx-4 max-h-[90vh] overflow-y-auto">
      <div class="p-5 border-b border-dark-600 flex justify-between items-center">
        <h2 class="text-xl font-semibold">Share Your Feedback</h2>
        <button id="closeFeedbackModal" class="text-gray-400 hover:text-white">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
          </svg>
        </button>
      </div>
      
      <div class="p-5">
        <form method="POST" name="feedback" data-netlify="true">
          <input type="hidden" name="form-name" value="feedback">
          <input type="hidden" id="feedbackModel" name="model" value="llama-3-70b">
          <input type="hidden" id="feedbackReasoning" name="reasoning_method" value="COD-5">
          
          <div class="mb-4">
            <label for="feedbackType" class="block text-sm font-medium text-gray-300 mb-2">Feedback Type:</label>
            <select id="feedbackType" name="feedback_type" class="w-full bg-dark-600 border border-dark-500 text-white rounded-lg p-3 focus:outline-none focus:ring-2 focus:ring-primary-500">
              <option value="general" selected="">General Feedback</option>
              <option value="bug">Report a Bug</option>
              <option value="feature">Feature Request</option>
              <option value="model_performance">Model Performance</option>
            </select>
          </div>
          
          <div class="mb-4">
            <label class="block text-sm font-medium text-gray-300 mb-3">How would you rate your experience?</label>
            <div class="flex justify-between">
              <label class="flex flex-col items-center cursor-pointer">
                <input type="radio" name="rating" value="1" class="sr-only peer" required="">
                <div class="text-2xl peer-checked:text-primary-400">üòû</div>
                <div class="text-xs mt-1 peer-checked:text-primary-400">Poor</div>
              </label>
              <label class="flex flex-col items-center cursor-pointer">
                <input type="radio" name="rating" value="2" class="sr-only peer">
                <div class="text-2xl peer-checked:text-primary-400">üòê</div>
                <div class="text-xs mt-1 peer-checked:text-primary-400">Fair</div>
              </label>
              <label class="flex flex-col items-center cursor-pointer">
                <input type="radio" name="rating" value="3" class="sr-only peer">
                <div class="text-2xl peer-checked:text-primary-400">üôÇ</div>
                <div class="text-xs mt-1 peer-checked:text-primary-400">Good</div>
              </label>
              <label class="flex flex-col items-center cursor-pointer">
                <input type="radio" name="rating" value="4" class="sr-only peer">
                <div class="text-2xl peer-checked:text-primary-400">üòÄ</div>
                <div class="text-xs mt-1 peer-checked:text-primary-400">Great</div>
              </label>
              <label class="flex flex-col items-center cursor-pointer">
                <input type="radio" name="rating" value="5" class="sr-only peer">
                <div class="text-2xl peer-checked:text-primary-400">ü§©</div>
                <div class="text-xs mt-1 peer-checked:text-primary-400">Excellent</div>
              </label>
            </div>
          </div>
          
          <div class="mb-4">
            <label for="feedbackComments" class="block text-sm font-medium text-gray-300 mb-2">Comments:</label>
            <textarea id="feedbackComments" name="comments" rows="4" required="" class="w-full bg-dark-600 border border-dark-500 text-white rounded-lg p-3 focus:outline-none focus:ring-2 focus:ring-primary-500"></textarea>
          </div>
          
          <button type="submit" class="w-full bg-primary-500 hover:bg-primary-600 text-white py-3 px-4 rounded-lg transition mt-2">
            Submit Feedback
          </button>
        </form>
      </div>
    </div>
  </div>

  <script>
    /***********************
     * Global Configuration
     ***********************/
    let MODEL_NAME = "";
    let MODEL_NAME_DISPLAY = "";
    let enableWebSearch = false;
    
    // API endpoints - primary and fallback
    const EDGE_API_URL = "/api/proxy";
    const FALLBACK_API_URL = "/api-fallback/proxy";
    // Keep the original for backward compatibility
    const API_PROXY_URL = EDGE_API_URL;
    
    // Reasoning Method
    let REASONING_METHOD = "cod"; // Options: "standard", "cot", "cod"
    
    // COD Word Limit
    let COD_WORD_LIMIT = 5;
    
    // Prompts for different reasoning methods
    let PROMPTS = {
      standard: "",
      
      cot: `Think step by step to solve this problem. Explain your reasoning at each step, then provide your final answer.`,
      
      cod: `Think step by step, but produce only minimal notes for each step (${COD_WORD_LIMIT} words maximum per step). Use mathematical notation where possible. Keep only essential information needed to solve the problem. Focus on key calculations and intermediate results without narrative explanation.

IMPORTANT: The word limit applies only to the reasoning steps. The final answer (including code or explanations) should be as detailed as needed and is NOT limited by the step word constraint.

Separate your steps with periods. Write your final answer after the #### separator.

Examples:
Q: Jason had 20 lollipops. He gave Denny some lollipops. Now Jason has 12 lollipops. How many lollipops did Jason give to Denny?
A: 20 initial. 12 remaining. 20 - 12 = 8. #### 8 lollipops

Q: Roger has $125. He spends $55 on a video game and then receives $25 for his birthday. How much money does Roger have now?
A: Start: $125. Spent: $55. 125 - 55 = $70. Received: $25. 70 + 25 = $95. #### $95

Q: A square has a perimeter of 20 cm. What is its area?
A: Perimeter = 20 cm. Side length = 20/4 = 5 cm. Area = 5¬≤ = 25 cm¬≤. #### 25 square centimeters

Q: If a fabric store received 45 yards of cotton material and used 2/9 of it for a bulk order, how many yards of cotton material does the fabric store have left?
A: Total: 45 yards. Used: 2/9 √ó 45 = 10 yards. Remaining: 45 - 10 = 35 yards. #### 35 yards

Q: The temperature on Monday was -3¬∞C. On Tuesday, it was 14¬∞C. What was the change in temperature from Monday to Tuesday?
A: Monday: -3¬∞C. Tuesday: 14¬∞C. Change: 14 - (-3) = 17¬∞C. #### 17¬∞C`
    };
    
    // Default generation parameters
    let TEMPERATURE = 0.6;
    let TOP_P = 1;
    let MAX_TOKENS = 4008;
    let TOP_K = 40;
    let PRESENCE_PENALTY = 0;
    let FREQUENCY_PENALTY = 0;

    // Initialize global self-reflection variables
    let SELF_REFLECTION_ENABLED = true;
    
    // Add streaming flag
    let ENABLE_STREAMING = true;
    
    /***********************
     * Helper Functions
     ***********************/
    
    // Update the model display in the UI
    function updateCurrentModelDisplay() {
      const display = document.getElementById("currentModelDisplay");
      if (!display) return;
      
      let displayText = MODEL_NAME_DISPLAY || "No model selected";
      
      // Add badge for reasoning method
      let badgeText = "Standard";
      let badgeClass = "bg-gray-600 text-gray-300";
      
      if (REASONING_METHOD === "cod") {
        badgeText = `CoD-${COD_WORD_LIMIT}`;
        badgeClass = "bg-green-900/60 text-green-400";
      } else if (REASONING_METHOD === "cot") {
        badgeText = "CoT";
        badgeClass = "bg-indigo-900/60 text-indigo-400";
      }
      
      // Update the display
      display.innerHTML = `<span>${displayText}</span><span class="${badgeClass} text-xs ml-2 px-2 py-0.5 rounded-full">${badgeText}</span>`;
    }
    
    // Get display name for model
    function getModelDisplayName(modelId) {
      const modelMap = {
        "accounts/fireworks/models/llama-v3p3-70b": "Llama-3 70B",
        "accounts/fireworks/models/deepseek-v3": "DeepSeek V3",
        "accounts/fireworks/models/deepseek-r1": "DeepSeek R1 (Reasoner)",
        "accounts/fireworks/models/llama4-maverick-instruct-basic": "Llama4 Maverick",
        "accounts/fireworks/models/llama4-scout-instruct-basic": "Llama4 Scout"
      };
      
      return modelMap[modelId] || modelId;
    }
    
    // Self-reflection initialization
    function initSelfReflection() {
      const toggle = document.getElementById('selfReflectionToggle');
      const infoPanel = document.getElementById('selfReflectionInfo');
      
      if (toggle) {
        toggle.checked = SELF_REFLECTION_ENABLED;
        
        toggle.addEventListener('change', () => {
          SELF_REFLECTION_ENABLED = toggle.checked;
          if (infoPanel) {
            infoPanel.style.display = SELF_REFLECTION_ENABLED ? 'block' : 'none';
          }
          updateCurrentModelDisplay();
        });
      }
    }
    
    // Save self-reflection settings
    function saveSelfReflectionSettings() {
      const toggle = document.getElementById('selfReflectionToggle');
      
      if (toggle) {
        SELF_REFLECTION_ENABLED = toggle.checked;
      }
      
      localStorage.setItem("selfReflectionEnabled", SELF_REFLECTION_ENABLED.toString());
    }
    
    /***********************
     * Thread Management
     ***********************/
    let threads = [];
    let currentThreadId = null;
    let threadCounter = 1;
    
    function createNewThread() {
      const newThread = {
        id: Date.now(),
        name: `Thread ${threadCounter++}`,
        messages: []
      };
      threads.push(newThread);
      currentThreadId = newThread.id;
      updateThreadList();
      renderCurrentThreadMessages();
      
      showNotification("New thread created");
    }
    
    function updateThreadList() {
      // Update main thread list
      const threadList = document.getElementById("threadList");
      if (threadList) {
        threadList.innerHTML = "";
        threads.forEach(thread => {
          const li = document.createElement("li");
          li.textContent = thread.name;
          li.className = "px-3 py-2 rounded-md cursor-pointer hover:bg-dark-500 transition";
          
          if (thread.id === currentThreadId) {
            li.classList.add("bg-dark-600", "text-primary-300");
          } else {
            li.classList.add("text-gray-300");
          }
          
          li.addEventListener("click", () => {
            currentThreadId = thread.id;
            renderCurrentThreadMessages();
            updateThreadList();
          });
          
          threadList.appendChild(li);
        });
      }
      
      // Update mobile thread list
      const mobileThreadList = document.getElementById("mobileThreadList");
      if (mobileThreadList) {
        mobileThreadList.innerHTML = "";
        threads.forEach(thread => {
          const li = document.createElement("li");
          li.textContent = thread.name;
          li.className = "px-3 py-2 rounded-md cursor-pointer hover:bg-dark-500 transition";
          
          if (thread.id === currentThreadId) {
            li.classList.add("bg-dark-600", "text-primary-300");
          } else {
            li.classList.add("text-gray-300");
          }
          
          li.addEventListener("click", () => {
            currentThreadId = thread.id;
            renderCurrentThreadMessages();
            updateThreadList();
            // Close mobile sidebar
            document.getElementById("mobileSidebar").classList.remove("translate-x-0");
            document.getElementById("mobileSidebar").classList.add("-translate-x-full");
          });
          
          mobileThreadList.appendChild(li);
        });
      }
    }
    
    function deleteCurrentThread() {
      if (!currentThreadId) return;
      if (confirm("Are you sure you want to delete this thread?")) {
        threads = threads.filter(thread => thread.id !== currentThreadId);
        if (threads.length > 0) {
          currentThreadId = threads[0].id;
        } else {
          createNewThread();
          return;
        }
        updateThreadList();
        renderCurrentThreadMessages();
        showNotification("Thread deleted");
      }
    }
    
    /***********************
     * Download Functions
     ***********************/
    function parseContentForExport(content) {
      if (!content) return []; 
      
      const result = [];
      const segments = content.split(/```/);
      for (let i = 0; i < segments.length; i++) {
        if (i % 2 === 0) {
          // Normal text
          const textLines = segments[i].split(/\r?\n/);
          textLines.forEach(line => {
            result.push({ type: 'text', content: line });
          });
        } else {
          // Code block
          const codeSegment = segments[i].trim();
          const firstNewlineIndex = codeSegment.indexOf('\n');
          let language = '';
          let codeContent = codeSegment;
          if (firstNewlineIndex !== -1) {
            const possibleLang = codeSegment.substring(0, firstNewlineIndex).trim();
            if (possibleLang && !possibleLang.includes(' ')) {
              language = possibleLang;
              codeContent = codeSegment.substring(firstNewlineIndex + 1);
            }
          }
          const codeLines = codeContent.split(/\r?\n/);
          result.push({ type: 'code', language: language, content: codeLines });
        }
      }
      return result;
    }
    
    function downloadCurrentThreadAsTxt() {
      const thread = threads.find(t => t.id === currentThreadId);
      if (!thread) {
        showNotification("Error: No active thread found");
        return;
      }
      
      let content = `Model: ${MODEL_NAME_DISPLAY || "Unknown"} (${REASONING_METHOD.toUpperCase()}`;
      if (REASONING_METHOD === "cod") {
        content += `-${COD_WORD_LIMIT}`;
      }
      content += `)\n\n`;
      
      thread.messages.forEach(msg => {
        if (msg.isPlaceholder) return;
        
        const prefix = msg.sender.toUpperCase();
        
        let headerInfo = prefix;
        if (msg.sender === "bot" && msg.wordCount !== undefined) {
          let countInfo = `[${msg.wordCount} words - ${msg.reasoningMethod || REASONING_METHOD.toUpperCase()}]`;
          if (msg.thinkingWordCount !== undefined && msg.answerWordCount !== undefined) {
            countInfo += ` (thinking: ${msg.thinkingWordCount}, answer: ${msg.answerWordCount})`;
          }
          headerInfo += ` ${countInfo}`;
        }
        
        content += `${headerInfo}:\n`;
        
        if (msg.sender === "bot" && msg.thinking && msg.answer) {
          content += `THINKING STEPS:\n${msg.thinking}\n\nFINAL ANSWER:\n${msg.answer}\n`;
        } else {
          try {
            const parsed = parseContentForExport(msg.content || "");
            parsed.forEach(item => {
              if (item.type === 'text') {
                content += item.content + '\n';
              } else if (item.type === 'code') {
                const lang = item.language ? ` (${item.language})` : '';
                content += `----- CODE BLOCK START${lang} -----\n`;
                item.content.forEach(line => {
                  content += `  ${line}\n`;
                });
                content += `----- CODE BLOCK END -----\n`;
              }
            });
          } catch (error) {
            console.error("Error parsing message content:", error);
            content += (msg.content || "") + '\n';
          }
        }
        content += '\n';
      });
      
      const blob = new Blob([content], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `${thread.name || "Thread"}.txt`;
      a.style.display = 'none';
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);
      
      showNotification("TXT file downloaded");
    }
    
    function downloadCurrentThreadAsPdf() {
      const thread = threads.find(t => t.id === currentThreadId);
      if (!thread) {
        showNotification("Error: No active thread found");
        return;
      }
      
      try {
        if (typeof window.jspdf === 'undefined' && typeof window.jsPDF === 'undefined') {
          throw new Error("PDF generation library not available. Try downloading as TXT instead.");
        }
        
        const jsPDF = window.jspdf?.jsPDF || window.jsPDF || window.jspdf;
        if (!jsPDF) {
          throw new Error("PDF generation library not properly loaded.");
        }
        
        const doc = new jsPDF({
          orientation: "portrait",
          unit: "pt",
          format: "letter"
        });
        
        // Helper function to set background color
        function setPageBackground(doc) {
          doc.setFillColor(24, 24, 27);
          doc.rect(0, 0, doc.internal.pageSize.width, doc.internal.pageSize.height, 'F');
        }
        
        // Set background for first page
        setPageBackground(doc);
        
        // Set text color and font
        doc.setTextColor(229, 231, 235);
        doc.setFont("helvetica");
        
        // Add title
        let yPos = 40;
        doc.setFontSize(16);
        const title = thread.name || "Thread";
        doc.text(title, 40, yPos);
        yPos += 20;
        
        // Add model info
        doc.setFontSize(12);
        let modelText = `Model: ${MODEL_NAME_DISPLAY || "Unknown"} (${REASONING_METHOD.toUpperCase()}`;
        if (REASONING_METHOD === "cod") {
          modelText += `-${COD_WORD_LIMIT}`;
        }
        modelText += `)`;
        doc.text(modelText, 40, yPos);
        yPos += 30;
        
        // Helper constants
        const lineHeight = 14;
        const leftMargin = 40;
        const rightMargin = 40;
        const pageWidth = doc.internal.pageSize.getWidth ? doc.internal.pageSize.getWidth() : doc.internal.pageSize.width;
        const pageHeight = (doc.internal.pageSize.getHeight ? doc.internal.pageSize.getHeight() : doc.internal.pageSize.height) - 50;
        const maxLineWidth = pageWidth - leftMargin - rightMargin;
        
        // Helper function to check if we need a new page
        function checkNewPage(requiredHeight = lineHeight) {
          if (yPos + requiredHeight > pageHeight) {
            doc.addPage();
            setPageBackground(doc);
            yPos = 40;
            return true;
          }
          return false;
        }
        
        // Helper function to split text
        function splitTextToFitPage(text, fontSize = 12) {
          doc.setFontSize(fontSize);
          return doc.splitTextToSize(text, maxLineWidth);
        }
        
        // Process each message
        thread.messages.forEach((msg, index) => {
          if (msg.isPlaceholder) return;
          
          // Add spacer between messages
          if (index > 0) {
            yPos += 20;
            checkNewPage();
          }
          
          // Message sender and timestamp
          doc.setFontSize(12);
          doc.setFont("helvetica", "bold");
          
          const sender = msg.sender.toUpperCase();
          let headerText = sender;
          
          // Add word count info for bot messages
          if (msg.sender === "bot" && msg.wordCount !== undefined) {
            let countInfo = `[${msg.wordCount} words - ${msg.reasoningMethod || REASONING_METHOD.toUpperCase()}]`;
            headerText += ` ${countInfo}`;
          }
          
          doc.text(headerText, leftMargin, yPos);
          yPos += lineHeight * 1.5;
          checkNewPage();
          
          // Message content
          doc.setFont("helvetica", "normal");
          doc.setFontSize(11);
          
          // Handle messages with thinking/answer components separately
          if (msg.sender === "bot" && msg.thinking && msg.answer) {
            // Thinking section
            doc.setFont("helvetica", "bold");
            doc.text("THINKING STEPS:", leftMargin, yPos);
            yPos += lineHeight * 1.5;
            checkNewPage();
            
            doc.setFont("helvetica", "normal");
            const thinkingLines = splitTextToFitPage(msg.thinking);
            thinkingLines.forEach(line => {
              checkNewPage();
              doc.text(line, leftMargin, yPos);
              yPos += lineHeight;
            });
            
            yPos += lineHeight;
            checkNewPage();
            
            // Answer section
            doc.setFont("helvetica", "bold");
            doc.text("FINAL ANSWER:", leftMargin, yPos);
            yPos += lineHeight * 1.5;
            checkNewPage();
            
            doc.setFont("helvetica", "normal");
            const answerLines = splitTextToFitPage(msg.answer);
            answerLines.forEach(line => {
              checkNewPage();
              doc.text(line, leftMargin, yPos);
              yPos += lineHeight;
            });
          } else {
            // Regular message content
            try {
              // Try to parse content with code blocks
              const parsed = parseContentForExport(msg.content || "");
              
              let isInCodeBlock = false;
              
              parsed.forEach(item => {
                if (item.type === 'text') {
                  if (isInCodeBlock) {
                    isInCodeBlock = false;
                    yPos += lineHeight;
                    checkNewPage();
                  }
                  
                  const lines = splitTextToFitPage(item.content);
                  lines.forEach(line => {
                    checkNewPage();
                    doc.text(line, leftMargin, yPos);
                    yPos += lineHeight;
                  });
                } else if (item.type === 'code') {
                  // Mark start of code block
                  yPos += lineHeight / 2;
                  checkNewPage();
                  
                  doc.setFont("courier", "normal");
                  doc.setFontSize(9);
                  
                  const langLabel = item.language ? ` (${item.language})` : '';
                  doc.text(`----- CODE BLOCK START${langLabel} -----`, leftMargin, yPos);
                  yPos += lineHeight;
                  
                  // Print code content with slight indent
                  item.content.forEach(line => {
                    checkNewPage();
                    const codeLine = `  ${line}`;
                    const codeLines = splitTextToFitPage(codeLine, 9);
                    codeLines.forEach(l => {
                      checkNewPage();
                      doc.text(l, leftMargin, yPos);
                      yPos += lineHeight;
                      checkNewPage();
                    });
                  });
                  
                  // Mark end of code block
                  checkNewPage();
                  doc.text(`----- CODE BLOCK END -----`, leftMargin, yPos);
                  yPos += lineHeight;
                  
                  // Reset font for normal text
                  doc.setFont("helvetica", "normal");
                  doc.setFontSize(11);
                  
                  isInCodeBlock = true;
                }
              });
            } catch (error) {
              console.error("Error parsing message for PDF:", error);
              // Fallback for parsing errors
              if (msg.content) {
                const lines = splitTextToFitPage(msg.content || "");
                lines.forEach(line => {
                  checkNewPage();
                  doc.text(line, leftMargin, yPos);
                  yPos += lineHeight;
                });
              }
            }
          }
        });
        
        // Save the PDF
        doc.save(`${thread.name || "Thread"}.pdf`);
        showNotification("PDF file downloaded");
        
      } catch (error) {
        console.error("PDF generation error:", error);
        showNotification("Error generating PDF: " + error.message);
        
        // Fallback to text download if PDF fails
        showNotification("Falling back to TXT download instead");
        setTimeout(() => downloadCurrentThreadAsTxt(), 1000);
      }
    }
    
    /***********************
     * Word Counting Utility
     ***********************/
    function countWords(text) {
      // Remove code blocks for more accurate word count
      const textWithoutCode = text.replace(/```[\s\S]*?```/g, '');
      
      // Count mathematical expressions as single words
      let processedText = textWithoutCode
        // Replace simple equations with single tokens
        .replace(/\b\w+\s*=\s*[\d\w+\-*/()]+/g, "EQUATION")
        // Replace fractions with single tokens
        .replace(/\b\d+\/\d+\b/g, "FRACTION")
        // Replace mathematical operations with spaces
        .replace(/[+\-*/=<>]+/g, " ");
      
      // Split by whitespace and filter out empty strings
      const words = processedText.split(/\s+/).filter(word => word.length > 0);
      return words.length;
    }
    
    /***********************
     * Parse user message for word count requirements
     ***********************/
    function formatFinalAnswer(answer) {
      if (!answer) return '';
      
      // Clean up the answer text
      let formattedAnswer = answer.trim();
      
      // Remove any leading markers if they exist
      formattedAnswer = formattedAnswer.replace(/^(Answer:|Final answer:|The answer is:|Therefore,|Thus,|Hence,)/i, '').trim();
      
      return formattedAnswer;
    }
    
    function parseWordCountRequest(message) {
      // Common patterns for word count requests
      const patterns = [
        /(\d+)\s*words?/i,
        /in\s*(\d+)\s*words/i,
        /limit\s*(\d+)\s*words/i,
        /answer\s*in\s*(\d+)\s*words/i,
        /respond\s*in\s*(\d+)\s*words/i,
        /keep\s*it\s*to\s*(\d+)\s*words/i,
        /no\s*more\s*than\s*(\d+)\s*words/i,
        /under\s*(\d+)\s*words/i,
        /maximum\s*of\s*(\d+)\s*words/i,
        /max\s*(\d+)\s*words/i
      ];
      
      // Check each pattern
      for (const pattern of patterns) {
        const match = message.match(pattern);
        if (match && match[1]) {
          const wordCount = parseInt(match[1]);
          if (!isNaN(wordCount) && wordCount > 0) {
            return wordCount;
          }
        }
      }
      
      // No word count requirement found
      return null;
    }
    
    /***********************
     * Process Bot Messages for COD
     ***********************/
    function processBotMessage(content, reasoningMethod) {
      // For Chain of Draft (CoD) mode
      if (reasoningMethod === "cod") {
        const separatorIndex = content.indexOf("####");
        
        if (separatorIndex !== -1) {
          // Extract thinking steps and final answer
          let thinking = content.substring(0, separatorIndex).trim();
          let answer = content.substring(separatorIndex + 4).trim();
          
          // Check for reflection step
          const reflectionPatterns = [
            /reflection:/i,
            /reflecting:/i,
            /let's verify:/i,
            /verifying:/i,
            /checking work:/i,
            /self-check:/i
          ];
          
          let reflectionIndex = -1;
          let reflectionMatch = null;
          
          // Find the last occurring reflection step
          for (const pattern of reflectionPatterns) {
            const match = thinking.match(pattern);
            if (match && match.index > reflectionIndex) {
              reflectionIndex = match.index;
              reflectionMatch = match;
            }
          }
          
          if (reflectionIndex !== -1) {
            // Split the thinking into regular steps and reflection
            const regularSteps = thinking.substring(0, reflectionIndex).trim();
            const reflectionStep = thinking.substring(reflectionIndex).trim();
            
            // Format reflection step with special styling
            thinking = regularSteps + "\n\n" + reflectionStep;
          }
          
          return {
            content: content,
            thinking: thinking,
            answer: answer,
            thinkingWordCount: countWords(thinking),
            answerWordCount: countWords(answer),
            hasReflection: reflectionIndex !== -1
          };
        }
      }
      
      // For Chain of Thought (CoT) mode
      if (reasoningMethod === "cot") {
        // Look for potential conclusion markers
        const conclusionMarkers = [
          "Therefore", "In conclusion", "So,", "Thus,", "Hence,", 
          "The answer is", "To conclude", "Finally,", "In summary",
          "As a result", "Consequently", "The final answer"
        ];
        
        // Add a marker for just "Answer:" or "Final answer:" on its own line
        const answerMarkers = [
          /\n(Answer:|Final answer:)/i,
          /^(Answer:|Final answer:)/i,
          /\n(The answer is:|My answer is:|Final answer is:)/i
        ];
        
        // Try each answer marker pattern
        for (const pattern of answerMarkers) {
          const answerMatch = content.match(pattern);
          if (answerMatch && answerMatch.index !== undefined) {
            // Found a marker
            const thinking = content.substring(0, answerMatch.index).trim();
            const answer = content.substring(answerMatch.index + answerMatch[0].length).trim();
            
            return {
              content: content,
              thinking: thinking,
              answer: answer,
              thinkingWordCount: countWords(thinking),
              answerWordCount: countWords(answer)
            };
          }
        }
        
        // If no explicit answer marker, look for conclusion indicator words
        let lastMarkerIndex = -1;
        let bestMarker = "";
        
        for (const marker of conclusionMarkers) {
          // Check for the marker near the end of the text (last 40%)
          const startSearchPos = content.length * 0.6;
          const markerIndex = content.indexOf(marker, startSearchPos);
          
          if (markerIndex > lastMarkerIndex && markerIndex !== -1) {
            lastMarkerIndex = markerIndex;
            bestMarker = marker;
          }
        }
        
        // If we found a conclusion marker in a reasonable position
        if (lastMarkerIndex > content.length * 0.6) {
          const thinking = content.substring(0, lastMarkerIndex).trim();
          const answer = content.substring(lastMarkerIndex).trim();
          
          return {
            content: content,
            thinking: thinking,
            answer: answer,
            thinkingWordCount: countWords(thinking),
            answerWordCount: countWords(answer)
          };
        }
        
        // Last resort: if text has multiple paragraphs, try to use the last paragraph as answer
        const paragraphs = content.split(/\n\s*\n/);
        if (paragraphs.length > 1) {
          const lastParagraph = paragraphs[paragraphs.length - 1].trim();
          // Only use last paragraph as answer if it's relatively short compared to whole text
          if (lastParagraph.length < content.length * 0.3) {
            const thinking = content.substring(0, content.lastIndexOf(lastParagraph)).trim();
            return {
              content: content,
              thinking: thinking,
              answer: lastParagraph,
              thinkingWordCount: countWords(thinking),
              answerWordCount: countWords(lastParagraph)
            };
          }
        }
      }
      
      // For standard reasoning
      if (reasoningMethod === "standard") {
        return {
          content: content,
          thinking: null, 
          answer: content,
          thinkingWordCount: 0,
          answerWordCount: countWords(content)
        };
      }
      
      // Default: if unable to separate, return entire content
      return {
        content: content,
        thinking: reasoningMethod === "cot" || reasoningMethod === "cod" ? content : null,
        answer: reasoningMethod === "standard" ? content : null,
        thinkingWordCount: reasoningMethod === "cot" || reasoningMethod === "cod" ? countWords(content) : 0,
        answerWordCount: reasoningMethod === "standard" ? countWords(content) : 0
      };
    }
    
    /***********************
     * Format Thinking Steps for COD
     ***********************/
    function formatThinkingSteps(thinking, reasoningMethod) {
      if (!thinking) return '';
      
      // Remove any "###" prefixes
      let cleanedThinking = thinking.replace(/^#{1,3}\s*/gm, '');
      
      if (reasoningMethod === "cod") {
        // Split by periods to separate steps, but preserve periods within numbers
        let steps = cleanedThinking.split(/\.(?!\d)/).filter(step => step.trim().length > 0);

        // Improved: Use a vertical timeline style for steps
        return `<ol class="relative border-l-2 border-primary-700 ml-4 pl-6">` +
          steps.map((step, index) => {
            // Check if this is a reflection step
            const isReflection = /reflection:|reflecting:|let's verify:|verifying:|checking work:|self-check:/i.test(step);
            let stepContent = step.trim();
            if (!isReflection && !stepContent.endsWith('.')) stepContent += '.';

            if (isReflection) {
              return `<li class="mb-6 ml-2">
                <span class="absolute -left-5 flex items-center justify-center w-8 h-8 bg-indigo-700/70 rounded-full border-2 border-indigo-400 text-indigo-200 font-bold shadow-lg">üîç</span>
                <div class="bg-indigo-900/40 border border-indigo-500 rounded-lg px-4 py-2 shadow-md">
                  <span class="font-mono text-sm text-indigo-200">${stepContent}</span>
                </div>
              </li>`;
            }
            return `<li class="mb-6 ml-2">
              <span class="absolute -left-5 flex items-center justify-center w-8 h-8 bg-primary-700/80 rounded-full border-2 border-primary-400 text-primary-100 font-bold shadow">${index + 1}</span>
              <div class="bg-dark-800 border border-primary-800/40 rounded-lg px-4 py-2 shadow">
                <span class="font-mono text-sm">${stepContent}</span>
              </div>
            </li>`;
          }).join('') +
        `</ol>`;
      } else {
        // Original formatting for CoT
        let steps = cleanedThinking.split(/\.\s+/);
        return `<ol class="relative border-l-2 border-indigo-700 ml-4 pl-6">` +
          steps.filter(step => step.trim())
            .map((step, idx) =>
              `<li class="mb-6 ml-2">
                <span class="absolute -left-5 flex items-center justify-center w-8 h-8 bg-indigo-700/80 rounded-full border-2 border-indigo-400 text-indigo-100 font-bold shadow">${idx + 1}</span>
                <div class="bg-dark-800 border border-indigo-800/40 rounded-lg px-4 py-2 shadow">
                  <span>${step.trim()}${!step.endsWith('.') ? '.' : ''}</span>
                </div>
              </li>`
            ).join('') +
          `</ol>`;
      }
    }

    /***********************
     * Transform Message
     ***********************/
    function transformMessage(content) {
      if (!content) return '';
      
      // Remove "###" prefixes from lines
      let processedContent = content.replace(/^#{1,3}\s*/gm, '');
      
      // Process markdown with marked.js if available
      if (typeof marked !== 'undefined') {
        return marked.parse(processedContent);
      } else {
        // Simple markdown-like transformation for code blocks if marked is not available
        const transformed = processedContent.replace(/```([\s\S]*?)```/g, (match, codeContent) => {
          let language = '';
          const lines = codeContent.split('\n');
          if (lines.length > 0 && !lines[0].includes(' ')) {
            language = lines[0].trim();
            lines.shift();
          }
          return `<pre><code class="${language}">${lines.join('\n')}</code></pre>`;
        });
        
        return transformed;
      }
    }
    
    /***********************
     * Rendering Messages
     ***********************/
    function renderCurrentThreadMessages() {
      const chatMessagesDiv = document.getElementById("chatMessages");
      if (!chatMessagesDiv) return;
      
      chatMessagesDiv.innerHTML = "";
      const thread = threads.find(t => t.id === currentThreadId);
      
      if (thread) {
        thread.messages.forEach(msg => {
          // Create message container
          const messageDiv = document.createElement("div");
          
          // Apply different styling based on sender
          if (msg.sender === "user") {
            messageDiv.className = "flex justify-end";
            
            const msgContent = document.createElement("div");
            msgContent.className = "max-w-[90%] bg-primary-600 text-white p-4 rounded-2xl rounded-tr-sm shadow-md";
            
            // Format and set content
            msgContent.innerHTML = transformMessage(msg.content);
            
            // Add files to user messages if present
            if (msg.files && msg.files.length > 0) {
              addFilesToMessage(msgContent, msg.files);
            }
            
            messageDiv.appendChild(msgContent);
          } else {
            // Bot message
            messageDiv.className = "flex justify-start";
            
            const msgContent = document.createElement("div");
            msgContent.className = "max-w-[90%] bg-dark-700 border border-dark-500 p-4 rounded-2xl rounded-tl-sm shadow-md";
            
            // Handle placeholder messages
            if (msg.isPlaceholder) {
              msgContent.classList.add("opacity-70");
              msgContent.innerHTML = `<div class="flex items-center gap-2">
                <svg class="animate-spin h-4 w-4 text-primary-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                  <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                  <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                ${msg.content}
              </div>`;
            } 
            // Handle streaming messages
            else if (msg.isStreaming) {
              msgContent.classList.add("streaming");
              msgContent.innerHTML = transformMessage(msg.content);
              msgContent.innerHTML += `<div class="text-primary-400 text-xs mt-2 streaming-indicator">Generating</div>`;
            } 
            // Handle thinking/answer messages
            else if (msg.thinking) {
              // Thinking steps
              const thinkingContainer = document.createElement("div");
              thinkingContainer.className = "thinking-steps bg-dark-800 rounded-lg p-4 mb-4 border border-dark-600";
              
              // Add label for thinking steps
              const thinkingLabel = document.createElement("div");
              thinkingLabel.className = "text-xs uppercase tracking-wider font-semibold text-primary-400 mb-3 pb-2 border-b border-dark-500";
              thinkingLabel.textContent = msg.reasoningMethod && msg.reasoningMethod.startsWith("COD") ? 
                "Chain of Draft Steps" : "Thinking Steps";
              thinkingContainer.appendChild(thinkingLabel);
              
              // Format thinking steps
              const thinkingContent = document.createElement("div");
              thinkingContent.innerHTML = formatThinkingSteps(
                msg.thinking, 
                msg.reasoningMethod ? msg.reasoningMethod.toLowerCase() : REASONING_METHOD
              );
              thinkingContainer.appendChild(thinkingContent);
              
              msgContent.appendChild(thinkingContainer);
              
              // Final answer
              if (msg.answer) {
                const answerDiv = document.createElement("div");
                answerDiv.className = "bg-gradient-to-br from-primary-900/60 to-dark-800 rounded-lg p-6 border-2 border-primary-700 shadow-lg mt-2";
                
                const answerLabel = document.createElement("div");
                answerLabel.className = "text-xs uppercase tracking-wider font-bold text-primary-300 mb-3 pb-2 border-b border-primary-700";
                answerLabel.textContent = "Final Answer";
                answerDiv.appendChild(answerLabel);
                
                const answerContent = document.createElement("div");
                answerContent.className = "text-lg font-mono text-primary-100";
                answerContent.innerHTML = transformMessage(formatFinalAnswer(msg.answer));
                answerDiv.appendChild(answerContent);
                
                msgContent.appendChild(answerDiv);
              }
            } 
            // Default content display
            else {
              msgContent.innerHTML = transformMessage(msg.content);
            }
            
            // Add word count badge for bot messages (except placeholders)
            if (!msg.isPlaceholder && msg.wordCount !== undefined) {
              const wordCountBadge = document.createElement("div");
              wordCountBadge.className = "absolute -top-1 -right-1 bg-dark-800 text-xs px-2 py-1 rounded-full border border-dark-600 shadow-md";
              
              // Display reasoning method and word count
              let badgeText = `${msg.wordCount} words`;
              
              if (msg.thinkingWordCount !== undefined && msg.answerWordCount !== undefined) {
                badgeText = `<span class="text-gray-400">${msg.thinkingWordCount}</span> + <span class="text-primary-400">${msg.answerWordCount}</span>`;
              }
              
              wordCountBadge.innerHTML = badgeText;
              
              // Make the container relative for absolute positioning
              msgContent.style.position = "relative";
              msgContent.appendChild(wordCountBadge);
            }
            
            // Add the content to the message div
            messageDiv.appendChild(msgContent);
          }
          
          chatMessagesDiv.appendChild(messageDiv);
        });
        
        // Scroll to the bottom
        chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight;
      }
      
      // Add syntax highlighting to code blocks
      if (typeof hljs !== 'undefined') {
        document.querySelectorAll('pre code').forEach((block) => {
          hljs.highlightElement(block);
        });
      }
      
      // Add copy buttons to code blocks
      addCodeCopyButtons();
    }
    
    function addMessageToCurrentThread(content, sender, isPlaceholder = false, files = []) {
      const thread = threads.find(t => t.id === currentThreadId);
      if (thread) {
        // Process bot messages to separate thinking from answer
        let thinking = null;
        let answer = null;
        let thinkingWordCount = 0;
        let answerWordCount = 0;
        let totalWordCount = 0;
        
        if (sender === "bot" && !isPlaceholder) {
          const processed = processBotMessage(content, REASONING_METHOD);
          thinking = processed.thinking;
          answer = processed.answer;
          thinkingWordCount = processed.thinkingWordCount || 0;
          answerWordCount = processed.answerWordCount || 0;
          totalWordCount = thinkingWordCount + answerWordCount;
        }
        
        thread.messages.push({
          content,
          sender,
          isPlaceholder,
          timestamp: new Date(),
          wordCount: sender === "bot" && !isPlaceholder ? totalWordCount : undefined,
          reasoningMethod: sender === "bot" && !isPlaceholder ? 
            (REASONING_METHOD === "cod" ? `${REASONING_METHOD.toUpperCase()}-${COD_WORD_LIMIT}` : REASONING_METHOD.toUpperCase()) : 
            undefined,
          thinking,
          answer,
          thinkingWordCount: sender === "bot" && !isPlaceholder ? thinkingWordCount : undefined,
          answerWordCount: sender === "bot" && !isPlaceholder ? answerWordCount : undefined,
          // Add files to the message
          files: files && files.length > 0 ? files : undefined,
        });
        
        renderCurrentThreadMessages();
      }
    }
    
    /***********************
     * Build Messages Array for Chat Completions
     ***********************/
    function buildMessagesForChat(wordCountRequest = null) {
      const thread = threads.find(t => t.id === currentThreadId);
      if (!thread) return [];
      
      const messages = [];
      const supportsMultimodal = doesModelSupportMultimodal(MODEL_NAME);
      
      let systemPrompt = "";
      
      // If we have a reasoning method other than standard, add the system prompt
      if (REASONING_METHOD !== "standard") {
        // Determine which prompt to use based on complexity and settings
        if (REASONING_METHOD === "cod") {
          // First update the word limit
          systemPrompt = PROMPTS.cod.replace(/\(\d+ words maximum per step\)/, `(${COD_WORD_LIMIT} words maximum per step)`);
          
          // If self-reflection is enabled but not in the prompt, add it
          if (SELF_REFLECTION_ENABLED && !systemPrompt.includes("add a reflection step")) {
            const reflectionInstruction = "\n\nBefore providing your final answer, add a reflection step starting with \"Reflection:\" to verify your work and catch any potential errors.";
            // Find a good place to insert - after the first paragraph but before examples
            const firstParagraphEnd = systemPrompt.indexOf("\n\n");
            if (firstParagraphEnd !== -1) {
              const examplesStart = systemPrompt.indexOf("Examples:");
              if (examplesStart !== -1 && examplesStart > firstParagraphEnd) {
                systemPrompt = systemPrompt.substring(0, examplesStart) + reflectionInstruction + "\n\n" + systemPrompt.substring(examplesStart);
              } else {
                systemPrompt = systemPrompt.substring(0, firstParagraphEnd + 2) + reflectionInstruction + systemPrompt.substring(firstParagraphEnd + 2);
              }
            } else {
              systemPrompt += reflectionInstruction;
            }
          }
        } else {
          // Use the selected reasoning method prompt
          systemPrompt = PROMPTS[REASONING_METHOD];
        }
        
        let reasoningInfo = `${REASONING_METHOD.toUpperCase()}`;
        if (REASONING_METHOD === "cod") {
          reasoningInfo += `-${COD_WORD_LIMIT}`;
          if (SELF_REFLECTION_ENABLED) {
            reasoningInfo += " with self-reflection";
          }
        }
        
        console.log(`Using ${reasoningInfo} prompt`);
        
        if (wordCountRequest) {
          console.log(`Added instruction for ${wordCountRequest} word limit on final answer only`);
        }
        
        messages.push({
          role: "system",
          content: systemPrompt
        });
      } else {
        console.log("Using standard reasoning (no special prompt)");
        
        // If word count limit was requested, add a system message for it
        if (wordCountRequest && wordCountRequest > 0) {
          messages.push({
            role: "system",
            content: `Please limit your response to ${wordCountRequest} words maximum.`
          });
          console.log(`Added instruction for ${wordCountRequest} word limit`);
        }
      }
      
      // Add all user and assistant messages
      thread.messages
        .filter(msg => !msg.isPlaceholder)
        .forEach(msg => {
          if (msg.sender === "user" && msg.files && msg.files.length > 0 && supportsMultimodal) {
            // Check if we have any image files with dataUrl
            const hasImages = msg.files.some(file => 
              file.type.startsWith('image/') && file.dataUrl);
            
            if (hasImages) {
              // For messages with images, create multimodal message format
              const contentArray = [];
              
              // Add text content if present
              if (msg.content && msg.content.trim()) {
                contentArray.push({ 
                  type: "text", 
                  text: msg.content 
                });
              }
              
              // Add images to the content array
              msg.files.forEach(fileObj => {
                if (fileObj.type.startsWith('image/') && fileObj.dataUrl) {
                  contentArray.push({
                    type: "image_url",
                    image_url: {
                      url: fileObj.dataUrl
                    }
                  });
                }
              });
              
              // Add the multimodal message
              messages.push({
                role: "user",
                content: contentArray
              });
              
              console.log(`Added multimodal message with ${contentArray.length} parts`);
            } else {
              // No valid images, use text-only format
              messages.push({
                role: "user",
                content: msg.content
              });
            }
          } else {
            // Regular text message
            messages.push({
              role: msg.sender === "user" ? "user" : "assistant",
              content: msg.content
            });
          }
        });
      
      return messages;
    }
    
    /***********************
     * Message Sending
     ***********************/
    
    // Check which models support multimodal content
    function doesModelSupportMultimodal(modelName) {
      const multimodalModels = [
        'accounts/fireworks/models/deepseek-v3',
        'accounts/fireworks/models/llama-v3p3-70b',
        'accounts/fireworks/models/llama-v3p1-8b',
        'accounts/fireworks/models/qwen2p5',
        'accounts/fireworks/models/llama4-maverick',
        'accounts/fireworks/models/llama4-scout'
      ];
      
      return multimodalModels.some(supportedModel => 
        modelName && modelName.includes(supportedModel));
    }
    
    // Helper function to read files as base64 data URLs
    function readFileAsBase64(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
          resolve(reader.result); // This is the data URL
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }
    
    async function sendMessage(message) {
      // Get the current streaming setting
      const savedStreamingPref = localStorage.getItem('streamingEnabled');
      ENABLE_STREAMING = savedStreamingPref !== null ? savedStreamingPref === 'true' : ENABLE_STREAMING;
      
      console.log(`Current streaming state: ${ENABLE_STREAMING ? 'enabled' : 'disabled'}`);
      
      // Check if Web Search is enabled
      const useWebSearch = localStorage.getItem('webSearchEnabled') === 'true';
      
      // Process files for sending to the API
      const supportsMultimodal = doesModelSupportMultimodal(MODEL_NAME);
      let processedFiles = [];
      
      if (attachedFiles.length > 0) {
        try {
          console.log(`Processing ${attachedFiles.length} files for sending`);
          
          // Notify user if images won't be sent to the model
          if (!supportsMultimodal && attachedFiles.some(file => file.type.startsWith('image/'))) {
            showNotification(`Note: Selected model (${MODEL_NAME_DISPLAY}) may not fully support image input.`);
          }
          
          for (const file of attachedFiles) {
            // For images, read as data URL
            if (file.type.startsWith('image/')) {
              const dataUrl = await readFileAsBase64(file);
              processedFiles.push({
                originalFile: file,
                name: file.name,
                type: file.type,
                size: file.size,
                dataUrl: dataUrl
              });
              console.log(`Processed image file: ${file.name}`);
            } else {
              // For other files, just add metadata
              processedFiles.push({
                originalFile: file,
                name: file.name,
                type: file.type,
                size: file.size
              });
            }
          }
        } catch (error) {
          console.error('Error processing files:', error);
          showNotification('Error processing files for upload');
        }
      }
      
      // Add message to thread with processed files
      addMessageToCurrentThread(message, "user", false, processedFiles);
      
      // Clear attached files after sending
      attachedFiles = [];
      const attachedFilesContainer = document.getElementById('attachedFiles');
      if (attachedFilesContainer) {
        attachedFilesContainer.innerHTML = '';
        attachedFilesContainer.style.display = 'none';
      }
      
      // If we're not using web search, make sure we have a model selected
      if (!useWebSearch && !MODEL_NAME) {
        const errorMsg = "Error: Please select a model in the Settings or enable Web Search.";
        addMessageToCurrentThread(errorMsg, "bot");
        console.error(errorMsg);
        return;
      }
      
      // Parse message for word count requirements
      const wordCountRequest = parseWordCountRequest(message);
      
      // Add placeholder message showing we're thinking
      let placeholderText = useWebSearch ? "Searching the web..." : "Thinking...";
      addMessageToCurrentThread(placeholderText, "bot", true);
      const thread = threads.find(t => t.id === currentThreadId);
      const placeholderIndex = thread.messages.length - 1;
      
      try {
        // Continue with Web Search or regular API calls
        if (useWebSearch) {
          // Web search logic would go here
          // For now, just show an error message
          thread.messages[placeholderIndex] = {
            content: "Web search is not implemented in this version.",
            sender: "bot",
            isPlaceholder: false,
            timestamp: new Date(),
            wordCount: 0,
            reasoningMethod: "STANDARD",
            thinking: null,
            answer: null,
            thinkingWordCount: 0,
            answerWordCount: 0
          };
          renderCurrentThreadMessages();
          return;
        }
        
        // Build messages array with current settings and word count request
        const messagesForApi = buildMessagesForChat(wordCountRequest);
        
        // Validate max_tokens before sending to API
        let validatedMaxTokens = parseInt(MAX_TOKENS);
        
        // Ensure it's a valid number
        if (isNaN(validatedMaxTokens) || !isFinite(validatedMaxTokens)) {
          validatedMaxTokens = 4096; // Default to 4096 if invalid
          console.warn(`Invalid max_tokens value, defaulting to ${validatedMaxTokens}`);
        }
        
        // Enforce model's limits
        validatedMaxTokens = Math.min(Math.max(1, validatedMaxTokens), 8192);
        if (validatedMaxTokens !== MAX_TOKENS) {
          console.warn(`Adjusted max_tokens from ${MAX_TOKENS} to ${validatedMaxTokens} to meet API requirements`);
        }
        
        // Detect if the messages are too long
        const totalWords = messagesForApi.reduce((total, msg) => total + countWords(typeof msg.content === 'string' ? msg.content : JSON.stringify(msg.content)), 0);
        const estimatedTokens = totalWords * 1.5; // Rough estimate of tokens from words
        
        // If the prompt is large, adjust max_tokens
        let adjustedMaxTokens = validatedMaxTokens;
        if (estimatedTokens > 2000) {
          console.log(`Large prompt detected (est. ${Math.round(estimatedTokens)} tokens). Reducing max_tokens to avoid timeouts.`);
          adjustedMaxTokens = Math.min(4096, validatedMaxTokens);
        }
        
        // Final validation to ensure we're within model's limits
        adjustedMaxTokens = Math.min(Math.max(1, adjustedMaxTokens), 8192);
        
        // Add timestamp to URL to prevent caching
        const timestamp = new Date().getTime();
        const cacheBuster = `?t=${timestamp}`;
        
        // Create payload for API request
        const payload = {
          model: MODEL_NAME,
          messages: messagesForApi,
          temperature: TEMPERATURE,
          top_p: TOP_P,
          max_tokens: adjustedMaxTokens,
          stream: ENABLE_STREAMING // Use the streaming flag
        };
        
        // Check if we should use streaming
        if (ENABLE_STREAMING) {
          console.log("Using streaming mode with Edge Function");
          
          try {
            // Update the placeholder to indicate streaming
            thread.messages[placeholderIndex].content = "Connecting to streaming API...";
            renderCurrentThreadMessages();
            
            // Prepare to collect the full response
            let fullResponse = "";
            let renderPending = false;
            
            // First send the initial request to start the stream
            const initResponse = await fetch(`/api/streaming-edge${cacheBuster}`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload)
            });
            
            if (!initResponse.ok) {
              throw new Error(`Error starting stream: ${initResponse.status}`);
            }
            
            // Set up event source for streaming
            const reader = initResponse.body.getReader();
            const decoder = new TextDecoder();
            
            // Process the stream
            while (true) {
              const { done, value } = await reader.read();
              
              if (done) {
                console.log("Stream complete");
                break;
              }
              
              // Decode this chunk
              const chunk = decoder.decode(value, { stream: true });
              
              // Process SSE format (data: {...}\n\n)
              const lines = chunk.split('\n');
              
              for (const line of lines) {
                if (line.startsWith('data: ')) {
                  // Extract the data part
                  const dataText = line.slice(6).trim();
                  
                  // Special end marker
                  if (dataText === '[DONE]') {
                    console.log("Received [DONE] marker");
                    continue;
                  }
                  
                  try {
                    // Attempt to parse as JSON
                    const data = JSON.parse(dataText);
                    
                    // Check for errors from server
                    if (data.error === true) {
                      console.error("Streaming error:", data.message);
                      throw new Error(data.message || "Unknown streaming error");
                    }
                    
                    // Check for completion
                    if (data.done === true) {
                      console.log("Received done: true");
                      continue;
                    }
                    
                    // Extract new content
                    if (data.choices && data.choices[0]) {
                      // Get the content delta or content
                      const contentDelta = data.choices[0].delta?.content || 
                                          data.choices[0].message?.content || 
                                          "";
                      
                      if (contentDelta) {
                        // Add to full response
                        fullResponse += contentDelta;
                        
                        // Update the message
                        thread.messages[placeholderIndex] = {
                          content: fullResponse,
                          sender: "bot",
                          isPlaceholder: false,
                          timestamp: new Date(),
                          isStreaming: true // Flag as streaming
                        };
                        
                        // Use requestAnimationFrame for smoother rendering
                        if (!renderPending) {
                          renderPending = true;
                          requestAnimationFrame(() => {
                            renderCurrentThreadMessages();
                            renderPending = false;
                          });
                        }
                      }
                    }
                  } catch (parseError) {
                    // If not valid JSON, just append it as raw text
                    if (dataText && dataText !== '') {
                      console.log("Non-JSON data received:", dataText);
                      fullResponse += dataText;
                      
                      // Update the message with the raw text
                      thread.messages[placeholderIndex] = {
                        content: fullResponse,
                        sender: "bot",
                        isPlaceholder: false,
                        timestamp: new Date(),
                        isStreaming: true
                      };
                      
                      // Use requestAnimationFrame for smoother rendering
                      if (!renderPending) {
                        renderPending = true;
                        requestAnimationFrame(() => {
                          renderCurrentThreadMessages();
                          renderPending = false;
                        });
                      }
                    }
                  }
                }
              }
            }
            
            // Stream is complete - process the full response
            console.log("Stream complete, processing final response");
            
            // Create response metadata
            let reasoningInfo = REASONING_METHOD.toUpperCase();
            if (REASONING_METHOD === "cod") {
              reasoningInfo += `-${COD_WORD_LIMIT}`;
            }
            
            // Process bot message to separate thinking and answer parts
            const processed = processBotMessage(fullResponse, REASONING_METHOD);
            
            // Update with the finalized message (not streaming anymore)
            thread.messages[placeholderIndex] = {
              content: fullResponse,
              sender: "bot",
              isPlaceholder: false,
              timestamp: new Date(),
              wordCount: (processed.thinkingWordCount || 0) + (processed.answerWordCount || 0),
              reasoningMethod: reasoningInfo,
              thinking: processed.thinking,
              answer: processed.answer,
              thinkingWordCount: processed.thinkingWordCount || 0,
              answerWordCount: processed.answerWordCount || 0,
              isStreaming: false // No longer streaming
            };
            
            renderCurrentThreadMessages();
            
          } catch (streamingError) {
            console.error("Streaming error:", streamingError);
            
            // Fallback to non-streaming if streaming fails
            console.log("Falling back to non-streaming API...");
            thread.messages[placeholderIndex].content = "Streaming failed, falling back to regular API...";
            renderCurrentThreadMessages();
            
            // Set streaming to false in the payload for fallback
            payload.stream = false;
            
            // Continue with non-streaming approach below
            ENABLE_STREAMING = false; // Temporarily disable streaming
          }
        }
        
        // Only proceed with non-streaming approach if streaming is disabled or failed
        if (!ENABLE_STREAMING) {
          // Set a client-side timeout
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 35000); // 35 seconds timeout
          
          console.log("Sending request to Edge Function endpoint...");
          
          try {
            // First try: Send request to the Edge Function endpoint
            const response = await fetch(`${EDGE_API_URL}${cacheBuster}`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json"
              },
              body: JSON.stringify(payload),
              signal: controller.signal
            });
            
            // Clear the timeout
            clearTimeout(timeoutId);
            
            // If successful, process the response
            if (response.ok) {
              const data = await response.json();
              const botReply = data.choices &&
                              data.choices[0] &&
                              data.choices[0].message &&
                              data.choices[0].message.content;
              
              if (botReply) {
                const trimmedReply = botReply.trim();
                
                // Create response metadata
                let reasoningInfo = REASONING_METHOD.toUpperCase();
                if (REASONING_METHOD === "cod") {
                  reasoningInfo += `-${COD_WORD_LIMIT}`;
                }
                
                // Process bot message to separate thinking and answer parts
                const processed = processBotMessage(trimmedReply, REASONING_METHOD);
                
                thread.messages[placeholderIndex] = {
                  content: trimmedReply,
                  sender: "bot",
                  isPlaceholder: false,
                  timestamp: new Date(),
                  wordCount: (processed.thinkingWordCount || 0) + (processed.answerWordCount || 0),
                  reasoningMethod: reasoningInfo,
                  thinking: processed.thinking,
                  answer: processed.answer,
                  thinkingWordCount: processed.thinkingWordCount || 0,
                  answerWordCount: processed.answerWordCount || 0
                };
                renderCurrentThreadMessages();
                
                // Re-enable streaming for next message
                ENABLE_STREAMING = true;
                
                return;
              }
            } else {
              // If Edge Function returned an error response, try the fallback
              console.log(`Edge Function returned error ${response.status}, trying fallback...`);
              
              // Try to parse the error response
              let errorText = "Unknown error";
              try {
                const errorResponse = await response.json();
                errorText = errorResponse.message || errorResponse.error || `Status code: ${response.status}`;
              } catch (e) {
                console.error("Failed to parse error response:", e);
              }
              
              throw new Error(`Edge Function returned status: ${response.status} - ${errorText}`);
            }
          } catch (edgeError) {
            // If Edge Function failed completely, try the fallback
            console.log("Edge Function error, using fallback function:", edgeError.message);
            
            // Update placeholder message
            if (thread.messages[placeholderIndex].isPlaceholder) {
              thread.messages[placeholderIndex].content = "Edge Function error, trying fallback...";
              renderCurrentThreadMessages();
            }
            
            // Set a longer timeout for the fallback function
            const fallbackController = new AbortController();
            const fallbackTimeoutId = setTimeout(() => fallbackController.abort(), 60000); // 60 seconds timeout
            
            try {
              // Try the fallback serverless function
              const fallbackResponse = await fetch(`${FALLBACK_API_URL}${cacheBuster}`, {
                method: "POST",
                headers: {
                  "Content-Type": "application/json"
                },
                body: JSON.stringify({
                  ...payload,
                  max_tokens: Math.min(8192, adjustedMaxTokens) // Ensure within model limits
                }),
                signal: fallbackController.signal
              });
              
              // Clear the fallback timeout
              clearTimeout(fallbackTimeoutId);
              
              if (!fallbackResponse.ok) {
                // Try to get detailed error from response
                let errorMsg = `Status: ${fallbackResponse.status}`;
                try {
                  const errorData = await fallbackResponse.json();
                  errorMsg = errorData.message || errorData.error || errorMsg;
                } catch (e) {
                  // If we can't parse JSON, try text
                  try {
                    errorMsg = await fallbackResponse.text();
                  } catch (e2) {
                    // If all else fails, use status code
                    errorMsg = `Status: ${fallbackResponse.status}`;
                  }
                }
                
                throw new Error(`Both endpoints failed. ${errorMsg}`);
              }
              
              // Process the fallback response
              const fallbackData = await fallbackResponse.json();
              const botReply = fallbackData.choices &&
                            fallbackData.choices[0] &&
                            fallbackData.choices[0].message &&
                            fallbackData.choices[0].message.content;
              
              if (botReply) {
                const trimmedReply = botReply.trim() + "\n\n*Note: This response was generated using the fallback API endpoint.*";
                
                // Create response metadata
                let reasoningInfo = REASONING_METHOD.toUpperCase();
                if (REASONING_METHOD === "cod") {
                  reasoningInfo += `-${COD_WORD_LIMIT}`;
                }
                
                // Process bot message to separate thinking and answer parts
                const processed = processBotMessage(trimmedReply, REASONING_METHOD);
                
                thread.messages[placeholderIndex] = {
                  content: trimmedReply,
                  sender: "bot",
                  isPlaceholder: false,
                  timestamp: new Date(),
                  wordCount: (processed.thinkingWordCount || 0) + (processed.answerWordCount || 0),
                  reasoningMethod: reasoningInfo,
                  thinking: processed.thinking,
                  answer: processed.answer,
                  thinkingWordCount: processed.thinkingWordCount || 0,
                  answerWordCount: processed.answerWordCount || 0
                };
                renderCurrentThreadMessages();
                
                // Re-enable streaming for next message
                ENABLE_STREAMING = true;
                
                return;
              } else {
                throw new Error("No valid response from fallback endpoint");
              }
            } catch (fallbackError) {
              // Both edge function and fallback failed
              if (fallbackError.name === 'AbortError') {
                throw new Error("The fallback API also timed out. Try reducing max_tokens or using a simpler query.");
              } else {
                throw fallbackError;
              }
            }
          }
        }
      } catch (error) {
        console.error("Error:", error);
        
        let errorMessage = "Error: " + error.message;
        
        // Check for specific error types and provide helpful messages
        if (error.name === "AbortError") {
          errorMessage = "Request timed out. Try again with a shorter question or reduce max_tokens in settings.";
        } else if (error.message.includes("401")) {
          errorMessage = "Authentication failed. Please check if your API key is properly set in environment variables.";
        } else if (error.message.includes("429")) {
          errorMessage = "Rate limit exceeded. Please wait a moment before trying again.";
        } else if (error.message.includes("500")) {
          errorMessage = "Server error. Please try again later.";
        } else if (error.message.includes("502") || error.message.includes("504")) {
          errorMessage = "The API took too long to respond. Try reducing max_tokens in settings (should be 8192 or less).";
        } else if (error.message.includes("Failed to fetch")) {
          errorMessage = "Could not connect to the API. Please check your internet connection and try again.";
        } else if (error.message.includes("Both endpoints failed")) {
          errorMessage = "Both primary and fallback API endpoints failed. Please try again later with reduced max_tokens.";
        } else if (error.message.includes("max_tokens")) {
          errorMessage = "The API requires max_tokens to be between 1 and 8192. Please adjust your settings.";
        } else if (error.message.includes("stream")) {
          errorMessage = "Error with streaming mode. Trying again may help, or disable streaming in the code.";
        }
        
        thread.messages[placeholderIndex] = {
          content: errorMessage,
          sender: "bot",
          isPlaceholder: false,
          timestamp: new Date(),
          wordCount: 0,
          reasoningMethod: useWebSearch ? "WEB-SEARCH" : REASONING_METHOD.toUpperCase(),
          thinking: null,
          answer: null,
          thinkingWordCount: 0,
          answerWordCount: 0
        };
        
        renderCurrentThreadMessages();
        
        // Re-enable streaming for next message
        ENABLE_STREAMING = true;
      }
    }
    
    /***********************
     * Code Copy Feature
     ***********************/
    function addCodeCopyButtons() {
      const codeBlocks = document.querySelectorAll('pre code');
      codeBlocks.forEach(code => {
        // Skip if already has a copy button container
        if (code.parentElement.classList.contains('relative')) {
          return;
        }
        
        const pre = code.parentElement;
        
        // Create container div
        const container = document.createElement('div');
        container.className = 'relative mb-4 rounded-lg overflow-hidden';
        pre.parentNode.insertBefore(container, pre);
        container.appendChild(pre);
        
        // Add language badge if specified
        const codeClass = code.className;
        const language = codeClass.match(/language-([^\s]+)/)?.[1];
        if (language && language !== 'plaintext') {
          const langBadge = document.createElement('div');
          langBadge.className = 'absolute top-2 left-2 bg-dark-900/80 text-xs py-1 px-2 rounded text-gray-400';
          langBadge.textContent = language;
          container.appendChild(langBadge);
        }
        
        // Add styles to the pre element
        pre.className = 'bg-dark-900 rounded-lg p-4 overflow-x-auto text-sm';
        
        // Add copy button
        const copyBtn = document.createElement('button');
        copyBtn.className = 'absolute top-2 right-2 bg-dark-900/80 text-gray-400 hover:text-white text-xs py-1 px-2 rounded transition-colors';
        copyBtn.textContent = 'Copy';
        copyBtn.addEventListener('click', () => {
          navigator.clipboard.writeText(code.textContent || '')
            .then(() => {
              copyBtn.textContent = 'Copied!';
              copyBtn.classList.add('text-green-400');
              setTimeout(() => {
                copyBtn.textContent = 'Copy';
                copyBtn.classList.remove('text-green-400');
              }, 2000);
            })
            .catch(() => {
              copyBtn.textContent = 'Failed';
              copyBtn.classList.add('text-red-400');
              setTimeout(() => {
                copyBtn.textContent = 'Copy';
                copyBtn.classList.remove('text-red-400');
              }, 2000);
            });
        });
        
        container.appendChild(copyBtn);
      });
    }
    
    /***********************
     * Notification System
     ***********************/
    function showNotification(message, duration = 3000) {
      const notification = document.getElementById("statusNotification");
      notification.textContent = message;
      notification.classList.add("opacity-100");
      
      setTimeout(() => {
        notification.classList.remove("opacity-100");
      }, duration);
    }
    
    /***********************
     * File Upload Management
     ***********************/
    let attachedFiles = [];
    
    function handleFileInput() {
      const fileInput = document.getElementById('fileInput');
      const attachedFilesContainer = document.getElementById('attachedFiles');
      
      if (!fileInput || !attachedFilesContainer) return;
      
      fileInput.addEventListener('change', (event) => {
        try {
          const files = event.target.files;
          const maxFileSize = 10 * 1024 * 1024; // 10MB limit
          
          if (files.length > 0) {
            // Show the container if it was hidden
            attachedFilesContainer.classList.remove('hidden');
            
            // Process each file
            for (let i = 0; i < files.length; i++) {
              const file = files[i];
              
              // Check file size
              if (file.size > maxFileSize) {
                showNotification(`File ${file.name} is too large. Maximum size is 10MB`);
                continue;
              }
              
              // Check if the file is already in the list
              const isDuplicate = attachedFiles.some(f => f.name === file.name && f.size === file.size);
              if (isDuplicate) {
                showNotification(`File ${file.name} is already attached`);
                continue;
              }
              
              // Add file to attachedFiles array
              attachedFiles.push(file);
              
              // Create file preview
              createFilePreview(file, attachedFilesContainer);
            }
            
            // Reset the file input
            fileInput.value = '';
          }
        } catch (error) {
          console.error('Error handling file upload:', error);
          showNotification('Error uploading file. Please try again.');
        }
      });
    }
    
    function createFilePreview(file, container) {
      const filePreview = document.createElement('div');
      filePreview.className = 'relative bg-dark-700 rounded-lg p-2 border border-dark-600';
      
      // Create preview content based on file type
      if (file.type.startsWith('image/')) {
        // Create image preview for image files
        const reader = new FileReader();
        reader.onload = (e) => {
          const img = document.createElement('img');
          img.className = 'w-16 h-16 object-cover rounded';
          img.src = e.target.result;
          filePreview.appendChild(img);
          
          // Add file name
          const fileName = document.createElement('div');
          fileName.className = 'mt-1 text-xs text-gray-400 text-center truncate w-16';
          fileName.textContent = file.name.length > 15 ? file.name.substring(0, 12) + '...' : file.name;
          filePreview.appendChild(fileName);
        };
        reader.readAsDataURL(file);
      } else {
        // Create icon preview for non-image files
        const icon = document.createElement('div');
        icon.className = 'w-16 h-16 flex items-center justify-center bg-dark-600 rounded text-2xl';
        icon.textContent = getFileIcon(file.type);
        filePreview.appendChild(icon);
        
        // Add file name
        const fileName = document.createElement('div');
        fileName.className = 'mt-1 text-xs text-gray-400 text-center truncate w-16';
        fileName.textContent = file.name.length > 15 ? file.name.substring(0, 12) + '...' : file.name;
        filePreview.appendChild(fileName);
      }
      
      // Add remove button
      const removeButton = document.createElement('button');
      removeButton.className = 'absolute -top-2 -right-2 bg-red-500 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs';
      removeButton.textContent = '√ó';
      removeButton.addEventListener('click', () => {
        // Remove from array
        attachedFiles = attachedFiles.filter(f => f !== file);
        
        // Remove from DOM
        filePreview.remove();
        
        // Hide container if no files left
        if (attachedFiles.length === 0) {
          container.classList.add('hidden');
        }
      });
      filePreview.appendChild(removeButton);
      
      // Add the preview to the container
      container.appendChild(filePreview);
    }
    
    function getFileIcon(fileType) {
      if (fileType.startsWith('image/')) {
        return 'üñºÔ∏è';
      } else if (fileType.startsWith('text/')) {
        return 'üìÑ';
      } else if (fileType.includes('pdf')) {
        return 'üìë';
      } else if (fileType.includes('word') || fileType.includes('document')) {
        return 'üìù';
      } else if (fileType.includes('excel') || fileType.includes('spreadsheet')) {
        return 'üìä';
      } else if (fileType.includes('audio')) {
        return 'üéµ';
      } else if (fileType.includes('video')) {
        return 'üé¨';
      } else if (fileType.includes('zip') || fileType.includes('compressed')) {
        return 'üóúÔ∏è';
      } else if (fileType.includes('code') || fileType.includes('javascript') || fileType.includes('html') || fileType.includes('css')) {
        return 'üì±';
      } else {
        return 'üì¶';
      }
    }
    
    function addFilesToMessage(messageDiv, files) {
      if (!files || files.length === 0) return;
      
      const filesContainer = document.createElement('div');
      filesContainer.className = 'mt-3 space-y-2';
      
      files.forEach(file => {
        if (file.type.startsWith('image/')) {
          // Display images inline
          if (file.dataUrl) {
            // If we already have a data URL, use it directly
            const img = document.createElement('img');
            img.className = 'max-w-full rounded-lg cursor-pointer hover:opacity-90 transition-opacity';
            img.src = file.dataUrl;
            img.alt = file.name || 'Image';
            
            // Add click event to open full size image
            img.addEventListener('click', () => {
              window.open(file.dataUrl, '_blank');
            });
            
            filesContainer.appendChild(img);
          } else if (file.originalFile) {
            // If we have the original file object, read it
            const reader = new FileReader();
            reader.onload = (e) => {
              const img = document.createElement('img');
              img.className = 'max-w-full rounded-lg cursor-pointer hover:opacity-90 transition-opacity';
              img.src = e.target.result;
              img.alt = file.name || 'Image';
              
              // Add click event to open full size image
              img.addEventListener('click', () => {
                window.open(e.target.result, '_blank');
              });
              
              filesContainer.appendChild(img);
            };
            reader.readAsDataURL(file.originalFile);
          } else {
            // Original implementation for backward compatibility - direct File object
            const reader = new FileReader();
            reader.onload = (e) => {
              const img = document.createElement('img');
              img.className = 'max-w-full rounded-lg cursor-pointer hover:opacity-90 transition-opacity';
              img.src = e.target.result;
              img.alt = file.name || 'Image';
              
              // Add click event to open full size image
              img.addEventListener('click', () => {
                window.open(e.target.result, '_blank');
              });
              
              filesContainer.appendChild(img);
            };
            reader.readAsDataURL(file);
          }
        } else {
          // For non-image files, display as attachment
          const attachment = document.createElement('div');
          attachment.className = 'flex items-center bg-dark-600 p-2 rounded-lg';
          
          const icon = document.createElement('div');
          icon.className = 'text-xl mr-3 text-gray-400';
          icon.textContent = getFileIcon(file.type);
          attachment.appendChild(icon);
          
          const fileInfo = document.createElement('div');
          fileInfo.className = 'flex-1';
          
          const fileName = document.createElement('div');
          fileName.className = 'text-sm font-medium';
          fileName.textContent = file.name;
          fileInfo.appendChild(fileName);
          
          const fileSize = document.createElement('div');
          fileSize.className = 'text-xs text-gray-400';
          fileSize.textContent = formatFileSize(file.size);
          fileInfo.appendChild(fileSize);
          
          attachment.appendChild(fileInfo);
          filesContainer.appendChild(attachment);
        }
      });
      
      messageDiv.appendChild(filesContainer);
    }
    
    function formatFileSize(bytes) {
      if (bytes < 1024) return bytes + ' bytes';
      else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
      else return (bytes / 1048576).toFixed(1) + ' MB';
    }
    
    /***********************
     * Web Search Functions
     ***********************/
    function toggleWebSearch() {
      const btn = document.getElementById('webSearchBtn');
      if (!btn) return;
      
      // Toggle the state
      enableWebSearch = !enableWebSearch;
      
      // Store preference
      localStorage.setItem('webSearchEnabled', enableWebSearch.toString());
      
      // Update button appearance with active class
      if (enableWebSearch) {
        btn.classList.add('bg-primary-500', 'text-white');
        btn.classList.remove('bg-dark-500', 'text-gray-300');
        btn.title = "Web search is enabled (click to disable)";
      } else {
        btn.classList.remove('bg-primary-500', 'text-white');
        btn.classList.add('bg-dark-500', 'text-gray-300');
        btn.title = "Web search is disabled (click to enable)";
      }
      
      // Show notification
      showNotification(enableWebSearch ? 'Web search enabled' : 'Web search disabled');
      
      console.log(`Web search ${enableWebSearch ? 'enabled' : 'disabled'}`);
    }
    
    /***********************
     * Settings Management
     ***********************/
    
    // Tab handling
    function setupTabNavigation() {
      try {
        console.log("Setting up tab navigation");
        
        // Get all tab buttons and tab contents
        const tabButtons = document.querySelectorAll('.tab-btn');
        const tabContents = document.querySelectorAll('.tab-content');
        
        if (tabButtons.length === 0) {
          console.warn("No tab buttons found");
        }
        
        // Add click event listeners to tab buttons
        tabButtons.forEach(button => {
          button.addEventListener('click', () => {
            try {
              // Remove active class from all buttons and contents
              tabButtons.forEach(btn => {
                btn.classList.remove('bg-primary-500', 'text-white');
                btn.classList.add('text-gray-400');
              });
              
              tabContents.forEach(content => {
                content.classList.remove('active');
                content.style.display = 'none';
              });
              
              // Add active class to clicked button
              button.classList.add('bg-primary-500', 'text-white');
              button.classList.remove('text-gray-400');
              
              // Show corresponding tab content
              const tabId = button.getAttribute('data-tab');
              const tabContent = document.getElementById(tabId);
              if (tabContent) {
                tabContent.classList.add('active');
                tabContent.style.display = 'block';
              } else {
                console.warn(`Tab content with id "${tabId}" not found`);
              }
            } catch (err) {
              console.error("Error handling tab click:", err);
            }
          });
        });
      } catch (err) {
        console.error("Error in setupTabNavigation:", err);
      }
    }
    
    // Custom model handling
    function setupModelInput() {
      const modelSelect = document.getElementById('modelSelect');
      const setModelBtn = document.getElementById('setModelBtn');
      const modelInfoCard = document.getElementById('modelInfoCard');
      const selectedModelName = document.getElementById('selectedModelName');
      const modelTags = document.getElementById('modelTags');
      const modelDescription = document.getElementById('modelDescription');
      
      if (!modelSelect || !modelInfoCard) return;
      
      // Model information
      const modelInfo = {
        "accounts/fireworks/models/llama-v3p3-70b": {
          name: "Llama-3 70B",
          tags: ["Latest", "Versatile", "Chat"],
          description: "Meta's latest model with strong performance across a wide range of tasks."
        },
        "accounts/fireworks/models/deepseek-v3": {
          name: "DeepSeek V3",
          tags: ["Latest", "Versatile", "Advanced", "Chat"],
          description: "DeepSeek's latest model with strong all-around capabilities and reasoning."
        },
        "accounts/fireworks/models/deepseek-r1": {
          name: "DeepSeek R1 (Reasoner)",
          tags: ["Reasoner", "Advanced", "Complex Tasks"],
          description: "DeepSeek model focused on complex reasoning tasks."
        },
        "accounts/fireworks/models/llama4-maverick-instruct-basic": {
          name: "Llama4 Maverick",
          tags: ["New", "Llama4", "Vision", "1M Context"],
          description: "Llama 4 Maverick model with large context and vision capabilities."
        },
        "accounts/fireworks/models/llama4-scout-instruct-basic": {
          name: "Llama4 Scout",
          tags: ["New", "Llama4", "Vision", "128k Context"],
          description: "Llama 4 Scout model with vision capabilities."
        }
      };
      
      // Initialize with current model if set
      if (MODEL_NAME && modelInfo[MODEL_NAME]) {
        modelSelect.value = MODEL_NAME;
        updateModelInfo(MODEL_NAME);
      }
      
      // Update model info card when selection changes
      modelSelect.addEventListener('change', () => {
        const selectedModel = modelSelect.value;
        updateModelInfo(selectedModel);
        
        // Show visual feedback on change
        modelSelect.style.borderColor = 'var(--primary)';
        setTimeout(() => {
          modelSelect.style.borderColor = '';
        }, 500);
      });
      
      // Helper function to update model info
      function updateModelInfo(modelId) {
        if (!modelInfoCard) return;
        
        if (modelInfo[modelId]) {
          const info = modelInfo[modelId];
          
          // Update header
          if (selectedModelName) {
            selectedModelName.textContent = info.name;
          }
          
          // Update tags with animation
          if (modelTags) {
            modelTags.style.opacity = '0';
            setTimeout(() => {
              modelTags.innerHTML = info.tags
                .map(tag => `<span class="bg-primary-500/20 text-primary-300 text-xs px-2 py-1 rounded-full">${tag}</span>`)
                .join('');
              modelTags.style.opacity = '1';
            }, 150);
          }
          
          // Update description with animation
          if (modelDescription) {
            modelDescription.style.opacity = '0';
            setTimeout(() => {
              modelDescription.textContent = info.description;
              modelDescription.style.opacity = '1';
            }, 150);
          }
          
          // Show the card with animation
          modelInfoCard.classList.remove('hidden');
          modelInfoCard.style.opacity = '0';
          modelInfoCard.style.transform = 'translateY(10px)';
          
          requestAnimationFrame(() => {
            modelInfoCard.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
            modelInfoCard.style.opacity = '1';
            modelInfoCard.style.transform = 'translateY(0)';
          });
        } else {
          // Hide or reset the card if no valid model
          modelInfoCard.classList.add('hidden');
        }
      }
      
      // Set model button handler
      if (setModelBtn) {
        setModelBtn.addEventListener('click', () => {
          const modelName = modelSelect.value;
          if (modelName && modelInfo[modelName]) {
            MODEL_NAME = modelName;
            MODEL_NAME_DISPLAY = modelInfo[modelName].name;
            updateCurrentModelDisplay();
            showNotification('Model set: ' + MODEL_NAME_DISPLAY);
            
            // Add visual feedback
            setModelBtn.classList.add('bg-green-500');
            setModelBtn.textContent = "Model Set!";
            setTimeout(() => {
              setModelBtn.classList.remove('bg-green-500');
              setModelBtn.textContent = "Set Model";
            }, 1000);
          } else {
            showNotification('Please select a valid model');
          }
        });
      }
    }
    
    // Improved Chain of Draft word limit options UI
    function updateCoDOptionsUI() {
      const codOptions = document.querySelector('.cod-word-limit-options');
      if (!codOptions) return;
      
      // Update selected state
      const options = codOptions.querySelectorAll('.cod-word-limit-option');
      options.forEach(option => {
        const value = parseInt(option.getAttribute('data-value'));
        if (value === COD_WORD_LIMIT) {
          option.classList.add('border-primary-500');
          option.classList.remove('border-dark-500', 'hover:border-primary-400');
        } else {
          option.classList.remove('border-primary-500');
          option.classList.add('border-dark-500', 'hover:border-primary-400');
        }
      });
      
      // Add event listeners to the word limit options
      options.forEach(option => {
        // Remove existing listeners
        const newOption = option.cloneNode(true);
        option.parentNode.replaceChild(newOption, option);
        
        // Add new listener
        newOption.addEventListener('click', () => {
          // Update selected state
          options.forEach(opt => {
            opt.classList.remove('border-primary-500');
            opt.classList.add('border-dark-500', 'hover:border-primary-400');
          });
          newOption.classList.add('border-primary-500');
          newOption.classList.remove('border-dark-500', 'hover:border-primary-400');
          
          // Update word limit value
          COD_WORD_LIMIT = parseInt(newOption.getAttribute('data-value'));
          
          // Update the prompt
          updateCoDPrompt();
          
          // Update display
          updateCurrentModelDisplay();
        });
      });
    }
    
    // Improved function to update the CoD prompt when word limit changes
    function updateCoDPrompt() {
      // Update the prompt to reflect new word limit
      const basePrompt = `Think step by step, but produce only minimal notes for each step (${COD_WORD_LIMIT} words maximum per step). Use mathematical notation where possible. Keep only essential information needed to solve the problem. Focus on key calculations and intermediate results without narrative explanation.
  
Separate your steps with periods. Write your final answer after the #### separator.`;
      
      // Add self-reflection instruction if enabled
      const basePromptWithReflection = SELF_REFLECTION_ENABLED ? 
        basePrompt + `\n\nBefore providing your final answer, add a reflection step starting with "Reflection:" to verify your work and catch any potential errors.` : 
        basePrompt;
      
      // Keep the examples part of the prompt
      const examplesStart = PROMPTS.cod.indexOf('Examples:');
      const clarification = "\n\nIMPORTANT: The word limit applies only to the reasoning steps. The final answer (including code or explanations) should be as detailed as needed and is NOT limited by the step word constraint.";
      if (examplesStart !== -1) {
        PROMPTS.cod = basePromptWithReflection + clarification + '\n\n' + PROMPTS.cod.substring(examplesStart);
      } else {
        PROMPTS.cod = basePromptWithReflection + clarification;
      }
      
      console.log(`Updated CoD prompt with word limit: ${COD_WORD_LIMIT}, self-reflection: ${SELF_REFLECTION_ENABLED}`);
    }
    
    // Setup COD options display
    function setupCODOptions() {
      const reasoningRadios = document.getElementsByName('reasoningMethod');
      const codOptions = document.getElementById('codOptions');
      
      if (!codOptions) return;
      
      // Initial state
      if (REASONING_METHOD === 'cod') {
        codOptions.style.display = 'block';
        updateCoDOptionsUI();
      } else {
        codOptions.style.display = 'none';
      }
      
      // Update when reasoning method changes
      reasoningRadios.forEach(radio => {
        radio.addEventListener('change', () => {
          if (radio.value === 'cod' && radio.checked) {
            codOptions.style.display = 'block';
            updateCoDOptionsUI();
          } else {
            codOptions.style.display = 'none';
          }
        });
      });
      
      // Also update CoD prompt when self-reflection setting changes
      const selfReflectionToggle = document.getElementById('selfReflectionToggle');
      if (selfReflectionToggle) {
        selfReflectionToggle.addEventListener('change', () => {
          if (REASONING_METHOD === 'cod') {
            updateCoDPrompt();
          }
        });
      }
    }
    
    // Settings slider handling
    function setupSliders() {
      // Connect all sliders to their value displays
      document.querySelectorAll('input[type="range"]').forEach(slider => {
        const valueDisplay = document.getElementById(`${slider.id}Value`);
        if (valueDisplay) {
          // Set initial value
          valueDisplay.textContent = slider.value;
          
          // Update color based on value
          updateRangeColor(slider);
          
          // Add input event listener
          slider.addEventListener('input', () => {
            valueDisplay.textContent = slider.value;
            updateRangeColor(slider);
          });
        }
      });
    }
    
    // Update range slider background
    function updateRangeColor(slider) {
      const min = parseFloat(slider.min) || 0;
      const max = parseFloat(slider.max) || 1;
      const value = parseFloat(slider.value) || 0;
      const percent = ((value - min) / (max - min)) * 100;
      slider.style.setProperty('--value-percent', `${percent}%`);
    }
    
    function openSettingsModal() {
      try {
        console.log("Opening settings modal");
        
        // Initialize settings UI
        
        // Set reasoning method radio buttons
        const reasoningRadio = document.getElementById(`${REASONING_METHOD}Reasoning`);
        if (reasoningRadio) reasoningRadio.checked = true;
        
        // Set parameter sliders
        setSliderAndValue("temp", TEMPERATURE);
        setSliderAndValue("topP", TOP_P);
        setSliderAndValue("maxTokens", MAX_TOKENS);
        setSliderAndValue("topK", TOP_K);
        setSliderAndValue("presencePenalty", PRESENCE_PENALTY);
        setSliderAndValue("frequencyPenalty", FREQUENCY_PENALTY);
        
        // Update CoD options UI if applicable
        if (REASONING_METHOD === 'cod') {
          const codOptions = document.getElementById('codOptions');
          if (codOptions) codOptions.style.display = 'block';
          updateCoDOptionsUI();
        }
        
        // Show modal
        const modal = document.getElementById("settingsModal");
        if (modal) modal.style.display = "flex";
        
        // Reset tab state
        const tabButtons = document.querySelectorAll('.tab-btn');
        const tabContents = document.querySelectorAll('.tab-content');
        
        // Hide all tabs first
        tabContents.forEach(content => {
          content.classList.remove('active');
          content.style.display = 'none';
        });
        
        // Deactivate all tab buttons
        tabButtons.forEach(btn => {
          btn.classList.remove('bg-primary-500', 'text-white');
          btn.classList.add('text-gray-400');
        });
        
        // Activate only the parameters tab by default
        const parametersTabBtn = document.querySelector('.tab-btn[data-tab="parametersTab"]');
        const parametersTab = document.getElementById('parametersTab');
        
        if (parametersTabBtn && parametersTab) {
          parametersTabBtn.classList.add('bg-primary-500', 'text-white');
          parametersTabBtn.classList.remove('text-gray-400');
          
          parametersTab.classList.add('active');
          parametersTab.style.display = 'block';
        }
        
        // Set web search toggle
        const webSearchToggle = document.getElementById('webSearchToggle');
        if (webSearchToggle) {
          webSearchToggle.checked = enableWebSearch;
        }
        
        // Set streaming toggle
        const streamingToggle = document.getElementById('streamingToggle');
        if (streamingToggle) {
          streamingToggle.checked = ENABLE_STREAMING;
        }
        
        console.log("Settings modal opened successfully");
      } catch (err) {
        console.error("Error in openSettingsModal:", err);
      }
    }
    
    function setSliderAndValue(id, value) {
      const slider = document.getElementById(id);
      const valueDisplay = document.getElementById(`${id}Value`);
      
      if (slider) {
        slider.value = value;
        updateRangeColor(slider);
      }
      if (valueDisplay) valueDisplay.textContent = value;
    }
    
    function closeSettingsModal() {
      const modal = document.getElementById("settingsModal");
      if (modal) modal.style.display = "none";
    }
    
    function saveSettings() {
      try {
        console.log("Saving settings...");
        
        // Save previous settings for comparison
        const prevMethod = REASONING_METHOD;
        const prevWordLimit = COD_WORD_LIMIT;
        
        // Get streaming setting
        const streamingToggle = document.getElementById('streamingToggle');
        if (streamingToggle) {
          ENABLE_STREAMING = streamingToggle.checked;
          localStorage.setItem('streamingEnabled', ENABLE_STREAMING.toString());
          console.log(`Streaming preference saved: ${ENABLE_STREAMING}`);
        }
        
        // Get web search setting
        const webSearchToggle = document.getElementById('webSearchToggle');
        if (webSearchToggle) {
          enableWebSearch = webSearchToggle.checked;
          localStorage.setItem('webSearchEnabled', enableWebSearch.toString());
          console.log(`Web search preference saved: ${enableWebSearch}`);
        }
        
        // Get model from select
        try {
          const modelSelect = document.getElementById("modelSelect");
          if (modelSelect && modelSelect.value) {
            MODEL_NAME = modelSelect.value.trim();
            MODEL_NAME_DISPLAY = getModelDisplayName(MODEL_NAME);
            console.log("Model saved:", MODEL_NAME, MODEL_NAME_DISPLAY);
          } else {
            console.warn("Model select not found or no value selected");
          }
        } catch (modelErr) {
          console.error("Error getting model:", modelErr);
        }
        
        // Save reasoning method
        try {
          const reasoningRadios = document.getElementsByName("reasoningMethod");
          for (const radio of reasoningRadios) {
            if (radio.checked) {
              REASONING_METHOD = radio.value;
              console.log("Reasoning method saved:", REASONING_METHOD);
              break;
            }
          }
        } catch (reasoningErr) {
          console.error("Error getting reasoning method:", reasoningErr);
        }
        
        // Save COD word limit if applicable
        if (REASONING_METHOD === "cod") {
          try {
            // Get the selected CoD word limit option
            const selectedOption = document.querySelector('.cod-word-limit-option.border-primary-500');
            if (selectedOption) {
              COD_WORD_LIMIT = parseInt(selectedOption.getAttribute('data-value'));
              console.log("COD word limit saved:", COD_WORD_LIMIT);
            }
          } catch (codErr) {
            console.error("Error getting COD word limit:", codErr);
          }
        }
        
        // Save self-reflection settings
        try {
          const selfReflectionToggle = document.getElementById('selfReflectionToggle');
          if (selfReflectionToggle) {
            SELF_REFLECTION_ENABLED = selfReflectionToggle.checked;
            console.log("Self-reflection enabled:", SELF_REFLECTION_ENABLED);
          }
        } catch (selfErr) {
          console.error("Error getting self-reflection settings:", selfErr);
        }
        
        // Save generation parameters safely with validation
        try {
          const tempSlider = document.getElementById("temp");
          if (tempSlider) {
            TEMPERATURE = parseFloat(tempSlider.value);
            if (TEMPERATURE === 0) TEMPERATURE = 0.01; // Ensure minimum value
          }
          
          const topPSlider = document.getElementById("topP");
          if (topPSlider) {
            TOP_P = parseFloat(topPSlider.value);
          }
          
          const topKSlider = document.getElementById("topK");
          if (topKSlider) {
            TOP_K = parseFloat(topKSlider.value);
          }
          
          const presencePenaltySlider = document.getElementById("presencePenalty");
          if (presencePenaltySlider) {
            PRESENCE_PENALTY = parseFloat(presencePenaltySlider.value);
          }
          
          const frequencyPenaltySlider = document.getElementById("frequencyPenalty");
          if (frequencyPenaltySlider) {
            FREQUENCY_PENALTY = parseFloat(frequencyPenaltySlider.value);
          }
          
          const maxTokensSlider = document.getElementById("maxTokens");
          if (maxTokensSlider) {
            // Enforce model's max_tokens limits (1-8192)
            const rawMaxTokens = parseInt(maxTokensSlider.value);
            MAX_TOKENS = Math.min(Math.max(1, rawMaxTokens), 8192);
            
            // Update the slider and display if needed
            if (MAX_TOKENS !== rawMaxTokens) {
              maxTokensSlider.value = MAX_TOKENS;
              const valueDisplay = document.getElementById('maxTokensValue');
              if (valueDisplay) valueDisplay.textContent = MAX_TOKENS;
              console.log(`Adjusted max_tokens from ${rawMaxTokens to ${MAX_TOKENS} to meet API requirements`);
            }
          }
          
          console.log("Parameters saved:", {TEMPERATURE, TOP_P, TOP_K, MAX_TOKENS, PRESENCE_PENALTY, FREQUENCY_PENALTY});
        } catch (paramsErr) {
          console.error("Error getting parameters:", paramsErr);
        }
        
        // Save settings to localStorage
        try {
          localStorage.setItem("modelName", MODEL_NAME);
          localStorage.setItem("reasoningMethod", REASONING_METHOD);
          localStorage.setItem("codWordLimit", COD_WORD_LIMIT.toString());
          localStorage.setItem("temperature", TEMPERATURE.toString());
          localStorage.setItem("topP", TOP_P.toString());
          localStorage.setItem("topK", TOP_K.toString());
          localStorage.setItem("presencePenalty", PRESENCE_PENALTY.toString());
          localStorage.setItem("frequencyPenalty", FREQUENCY_PENALTY.toString());
          localStorage.setItem("maxTokens", MAX_TOKENS.toString());
          localStorage.setItem("selfReflectionEnabled", SELF_REFLECTION_ENABLED.toString());
          
          // Save custom prompts
          localStorage.setItem("customPrompts", JSON.stringify(PROMPTS));
          console.log("Settings saved to localStorage");
        } catch (storageErr) {
          console.error("Error saving to localStorage:", storageErr);
        }
        
        // Update model display
        updateCurrentModelDisplay();
        
        closeSettingsModal();
        
        // Show appropriate notification
        if (prevMethod !== REASONING_METHOD || 
            (REASONING_METHOD === "cod" && prevMethod === "cod" && prevWordLimit !== COD_WORD_LIMIT)) {
          showNotification("Settings saved - reasoning method changed");
        } else {
          showNotification("Settings saved");
        }
      } catch (err) {
        console.error("Error in saveSettings:", err);
        showNotification("Error saving settings");
      }
    }
    
    /***********************
     * Feedback Form
     ***********************/
    function initFeedbackForm() {
      // Get references to elements
      const openBtn = document.getElementById('openFeedbackBtn');
      const mobileOpenBtn = document.getElementById('mobileOpenFeedbackBtn');
      const modal = document.getElementById('feedbackModal');
      const closeBtn = document.getElementById('closeFeedbackModal');
      const modelInput = document.getElementById('feedbackModel');
      const reasoningInput = document.getElementById('feedbackReasoning');
      
      // Function to open the feedback modal
      function openFeedbackModal() {
        // Update hidden fields with current model info
        if (modelInput) modelInput.value = MODEL_NAME_DISPLAY || 'Not set';
        if (reasoningInput) {
          let reasoningMethod = REASONING_METHOD.toUpperCase();
          if (REASONING_METHOD === 'cod') {
            reasoningMethod += `-${COD_WORD_LIMIT}`;
          }
          reasoningInput.value = reasoningMethod;
        }
        
        // Show the modal
        if (modal) modal.style.display = 'flex';
      }
      
      // Set up event listeners
      if (openBtn) {
        openBtn.addEventListener('click', openFeedbackModal);
      }
      
      if (mobileOpenBtn) {
        mobileOpenBtn.addEventListener('click', () => {
          // First close the mobile sidebar
          document.getElementById("mobileSidebar").classList.remove("translate-x-0");
          document.getElementById("mobileSidebar").classList.add("-translate-x-full");
          
          // Then open the feedback modal
          openFeedbackModal();
        });
      }
      
      if (closeBtn) {
        closeBtn.addEventListener('click', () => {
          if (modal) modal.style.display = 'none';
        });
      }
      
      // Close modal when clicking outside
      if (modal) {
        modal.addEventListener('click', (event) => {
          if (event.target === modal) {
            modal.style.display = 'none';
          }
        });
      }
      
      // Show success message after form submission
      const form = document.querySelector('form[name="feedback"]');
      if (form) {
        form.addEventListener('submit', (e) => {
          e.preventDefault();
          
          // Show success notification
          showNotification('Thank you for your feedback!');
          
          // Close the modal
          if (modal) modal.style.display = 'none';
          
          // Reset the form
          form.reset();
        });
      }
    }
    
    /***********************
     * Mobile Navigation
     ***********************/
    function initMobileNavigation() {
      const mobileSidebarToggle = document.getElementById('mobileSidebarToggle');
      const mobileSidebar = document.getElementById('mobileSidebar');
      const closeMobileSidebar = document.getElementById('closeMobileSidebar');
      
      if (mobileSidebarToggle && mobileSidebar) {
        mobileSidebarToggle.addEventListener('click', () => {
          mobileSidebar.classList.remove('-translate-x-full');
          mobileSidebar.classList.add('translate-x-0');
        });
      }
      
      if (closeMobileSidebar && mobileSidebar) {
        closeMobileSidebar.addEventListener('click', () => {
          mobileSidebar.classList.remove('translate-x-0');
          mobileSidebar.classList.add('-translate-x-full');
        });
      }
      
      // Mobile buttons should trigger their desktop counterparts
      document.getElementById('mobileNewThreadBtn')?.addEventListener('click', () => {
        createNewThread();
        mobileSidebar.classList.remove('translate-x-0');
        mobileSidebar.classList.add('-translate-x-full');
      });
      
      document.getElementById('mobileDeleteThreadBtn')?.addEventListener('click', () => {
        deleteCurrentThread();
        mobileSidebar.classList.remove('translate-x-0');
        mobileSidebar.classList.add('-translate-x-full');
      });
      
      document.getElementById('mobileDownloadTxtBtn')?.addEventListener('click', () => {
        downloadCurrentThreadAsTxt();
        mobileSidebar.classList.remove('translate-x-0');
        mobileSidebar.classList.add('-translate-x-full');
      });
      
      document.getElementById('mobileDownloadPdfBtn')?.addEventListener('click', () => {
        downloadCurrentThreadAsPdf();
        mobileSidebar.classList.remove('translate-x-0');
        mobileSidebar.classList.add('-translate-x-full');
      });
      
      document.getElementById('mobileClearThreadBtn')?.addEventListener('click', () => {
        if (confirm("Clear all messages in this thread?")) {
          const thread = threads.find(t => t.id === currentThreadId);
          if (thread) {
            thread.messages = [];
            renderCurrentThreadMessages();
            showNotification("Thread cleared");
          }
        }
        mobileSidebar.classList.remove('translate-x-0');
        mobileSidebar.classList.add('-translate-x-full');
      });
    }
    
    /***********************
     * Initialization
     ***********************/
    function loadPersistedSettings() {
      try {
        MODEL_NAME = localStorage.getItem("modelName") || "";
        MODEL_NAME_DISPLAY = getModelDisplayName(MODEL_NAME);
        
        REASONING_METHOD = localStorage.getItem("reasoningMethod") || "cod";
        
        const codWordLimit = localStorage.getItem("codWordLimit");
        if (codWordLimit) COD_WORD_LIMIT = parseInt(codWordLimit);
        
        // Load custom prompts if available
        const storedPrompts = localStorage.getItem("customPrompts");
        if (storedPrompts) {
          const parsedPrompts = JSON.parse(storedPrompts);
          // Merge with default prompts to ensure all properties exist
          PROMPTS = { ...PROMPTS, ...parsedPrompts };
        }
        
        const temp = localStorage.getItem("temperature");
        if (temp) TEMPERATURE = parseFloat(temp);
        
        const topP = localStorage.getItem("topP");
        if (topP) TOP_P = parseFloat(topP);
        
        const topK = localStorage.getItem("topK");
        if (topK) TOP_K = parseFloat(topK);
        
        const presencePenalty = localStorage.getItem("presencePenalty");
        if (presencePenalty) PRESENCE_PENALTY = parseFloat(presencePenalty);
        
        const frequencyPenalty = localStorage.getItem("frequencyPenalty");
        if (frequencyPenalty) FREQUENCY_PENALTY = parseFloat(frequencyPenalty);
        
        const maxTokens = localStorage.getItem("maxTokens");
        if (maxTokens) MAX_TOKENS = parseInt(maxTokens);
        
        // Load self-reflection settings
        const selfReflectionEnabled = localStorage.getItem("selfReflectionEnabled");
        if (selfReflectionEnabled !== null) {
          SELF_REFLECTION_ENABLED = selfReflectionEnabled === 'true';
        }
        
        // Load streaming preference
        const savedStreamingPref = localStorage.getItem('streamingEnabled');
        if (savedStreamingPref !== null) {
          ENABLE_STREAMING = savedStreamingPref === 'true';
        }
        
        // Load web search preference
        const webSearchEnabled = localStorage.getItem('webSearchEnabled');
        if (webSearchEnabled !== null) {
          enableWebSearch = webSearchEnabled === 'true';
        }
      } catch (err) {
        console.error("Error loading settings:", err);
      }
    }
    
    function initApp() {
      console.log("Initializing app...");
      
      try {
        loadPersistedSettings();
        console.log("Settings loaded");
        
        // Update CoD prompt with the correct word limit
        updateCoDPrompt();
        console.log("CoD prompt updated");
        
        createNewThread();
        console.log("New thread created");
        
        // Set up event listeners
        initEventListeners();
        console.log("Event listeners initialized");
        
        // Initialize mobile navigation
        initMobileNavigation();
        console.log("Mobile navigation initialized");
        
        updateCurrentModelDisplay();
        console.log("Model display updated");
        
        // Initialize feedback form
        initFeedbackForm();
        console.log("Feedback form initialized");
        
        // Add clear thread button event listener
        const clearThreadBtn = document.getElementById("clearThreadBtn");
        if (clearThreadBtn) {
          clearThreadBtn.addEventListener("click", () => {
            if (confirm("Clear all messages in this thread?")) {
              const thread = threads.find(t => t.id === currentThreadId);
              if (thread) {
                thread.messages = [];
                renderCurrentThreadMessages();
                showNotification("Thread cleared");
              }
            }
          });
          console.log("Clear thread button initialized");
        }
        
        // If we don't have a model name, open settings modal
        if (!MODEL_NAME) {
          console.log("No model name found, opening settings");
          setTimeout(() => {
            try {
              openSettingsModal();
              console.log("Settings modal opened");
            } catch (err) {
              console.error("Error opening settings modal:", err);
            }
          }, 1000);
        }
      } catch (err) {
        console.error("Initialization error:", err);
      }
    }
    
    function initEventListeners() {
      try {
        console.log("Initializing event listeners");
        
        // Helper function to safely add event listeners
        const addListener = (id, event, handler) => {
          const element = document.getElementById(id);
          if (element) {
            element.addEventListener(event, handler);
          } else {
            console.warn(`Element with id "${id}" not found for event listener`);
          }
        };
        
        // Settings buttons
        addListener("openSettings", "click", openSettingsModal);
        addListener("closeSettings", "click", closeSettingsModal);
        addListener("closeModalX", "click", closeSettingsModal);
        addListener("saveSettings", "click", saveSettings);
        
        // Thread management
        addListener("newThreadBtn", "click", createNewThread);
        addListener("deleteThreadBtn", "click", deleteCurrentThread);
        addListener("downloadTxtBtn", "click", downloadCurrentThreadAsTxt);
        addListener("downloadPdfBtn", "click", downloadCurrentThreadAsPdf);
        addListener("clearThreadBtn", "click", () => {
          if (confirm("Clear all messages in this thread?")) {
            const thread = threads.find(t => t.id === currentThreadId);
            if (thread) {
              thread.messages = [];
              renderCurrentThreadMessages();
              showNotification("Thread cleared");
            }
          }
        });
        
        // Web search toggle
        addListener("webSearchBtn", "click", toggleWebSearch);
        
        // Message input
        const textarea = document.getElementById('userInput');
        if (textarea) {
          textarea.addEventListener('input', () => {
            // Auto-resize textarea based on content
            textarea.style.height = 'auto';
            textarea.style.height = (textarea.scrollHeight) + 'px';
          });
          
          textarea.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
              e.preventDefault();
              document.getElementById('sendBtn')?.click();
            }
          });
        }
        
        // Send button
        addListener("sendBtn", "click", () => {
          const textarea = document.getElementById('userInput');
          if (textarea) {
            const message = textarea.value.trim();
            if (message || attachedFiles.length > 0) {
              sendMessage(message);
              textarea.value = '';
              textarea.style.height = 'auto';
            }
          }
        });
        
        // Initialize file upload
        handleFileInput();
        
        // Close modal when clicking outside
        window.addEventListener("click", (event) => {
          const settingsModal = document.getElementById("settingsModal");
          if (settingsModal && event.target === settingsModal) {
            closeSettingsModal();
          }
          
          const feedbackModal = document.getElementById("feedbackModal");
          if (feedbackModal && event.target === feedbackModal) {
            feedbackModal.style.display = 'none';
          }
        });
        
        // Set up settings UI functionality
        setTimeout(() => {
          try {
            setupTabNavigation();
            setupModelInput();
            setupCODOptions();
            setupSliders();
            initSelfReflection();
            console.log("UI functionality setup complete");
          } catch (err) {
            console.error("Error setting up UI functionality:", err);
          }
        }, 100);
      } catch (err) {
        console.error("Error initializing event listeners:", err);
      }
    }
    
    // Initialize the application
    document.addEventListener("DOMContentLoaded", async function() {
      try {
        console.log("Starting application initialization...");
        
        // Dark mode detection
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
          document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
          if (event.matches) {
            document.documentElement.classList.add('dark');
          } else {
            document.documentElement.classList.remove('dark');
          }
        });
        
        // Initialize the app
        await initApp();
        console.log("Application initialized successfully");
        
        // Initialize Web search button state
        const webSearchBtn = document.getElementById('webSearchBtn');
        if (webSearchBtn && enableWebSearch) {
          webSearchBtn.classList.add('bg-primary-500', 'text-white');
          webSearchBtn.classList.remove('bg-dark-500', 'text-gray-300');
        }
        
      } catch (error) {
        console.error("Error during application initialization:", error);
        showNotification("Error initializing application. Please refresh the page.");
      }
    });
  </script>


</body></html>
